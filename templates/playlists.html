{% extends "base.html" %}
{% block page_title %}Plex Collections{% endblock %}
{% block content %}

    <div class="playlist-header">
        <h2>Plex Collections</h2>
        <div class="tab-header">
            <button class="tab-btn active" onclick="openTab(event, 'tab-manager')">Auto-Manager</button>
        </div>
    </div>
    <div id="tab-manager" class="tab-content active playlists-center">
        <p class="media-sub">Curated lists, imported text, and custom builders.</p>

        <div class="stats-bar">
            <span class="stats-label">{{ custom_presets|length }} Custom</span>
            <span class="stats-label">|</span>
            <span class="stats-label">{{ presets|length }} Presets</span>
        </div>

        <div class="action-bar">
            <button class="btn-builder" onclick="window.location.href='{{ url_for('builder') }}'">Custom Builder</button>
            <button class="btn-import" onclick="openImportModal()">Import List</button>
        </div>

        <div class="type-toggle-group">
            <button onclick="filterType('movie')" id="btn-movie" class="type-toggle-btn active">Movies</button>
            <button onclick="filterType('tv')" id="btn-tv" class="type-toggle-btn">TV Shows</button>
        </div>

        <div class="schedule-time-row">
            <span class="schedule-label">Global Schedule Time:</span>
            <input type="time" id="globalTime" class="form-control schedule-time-input" value="{{ schedule_time }}">
            <button class="btn btn-primary schedule-save-btn" onclick="saveGlobalTime()">Save</button>
        </div>
        <span id="save-time-feedback" class="save-feedback" style="display:none;">Saved</span>
    </div>
    <div id="tab-viewer" class="tab-content">
        <div style="text-align:center; color:#aaa; margin-bottom: 30px;">
            <p>A live view of all collections currently existing on your Plex server.</p>
            <p class="viewer-visibility-hint">Use <strong>Home</strong>, <strong>Library</strong>, and <strong>Friends</strong> to match Plex‚Äôs Manage Recommendations (Library Recommended, Home, Friends' Home). In Plex: <strong>Settings -> Manage -> Libraries</strong>, then <strong>Manage Recommendations</strong>. There you can reorder collections and change which appear on Home, Library, or Friends. Requires Plex Pass and server 1.22.3+.</p>
            <button type="button" id="viewer-refresh-btn" class="btn btn-secondary" onclick="refreshLibraryBrowser()" style="margin-top:8px;">Refresh list</button>
        </div>

        <div id="viewer-loading" style="text-align:center; padding:50px;">
            <div class="spinner"></div>
            <h3 style="color:#ccc;">Fetching from Plex...</h3>
        </div>

        <div id="viewer-grid" class="playlist-grid" style="display:none; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));">
        </div>
    </div>
<div id="preview-modal" class="import-modal" onclick="if(event.target===this) closePreviewModal()">
    <div class="import-content wide">
        <span onclick="closePreviewModal()" class="close-btn">&times;</span>
        <h2 id="preview-title" style="margin-top:0;">üëÄ Collection Preview</h2>
        <div id="preview-grid" class="preview-grid"></div>
    </div>
</div>

<div id="import-modal" class="import-modal">
    <div class="import-content">
        <span onclick="closeImportModal()" class="close-btn">&times;</span>
        <h2 style="margin-top:0;">Import from List</h2>
        
        <details class="help-box">
            <summary>How does this work?</summary>
            <ol>
                <li><b>Copy & Paste:</b> Grab a list from Letterboxd, IMDb, or Reddit. We handle newlines, commas, or pipes `|`.</li>
                <li><b>Smart Matching:</b> "The Matrix (1999)" and "The Matrix" both work.</li>
                <li><b>One-Time Import:</b> These collections are static and cannot be auto-updated.</li>
            </ol>
        </details>
        
        <textarea id="import-text" rows="10" placeholder="The Matrix&#10;Inception, Interstellar&#10;The Dark Knight (2008)" class="import-textarea"></textarea>
        
        <div class="import-field">
            <label for="import-title" class="import-label">Collection Name</label>
            <input type="text" id="import-title" placeholder="e.g. My Favorites" class="import-title-input">
        </div>
        <div class="import-field">
            <label for="import-library" class="import-label">Library</label>
            <select id="import-library" class="import-select">
                <option value="" disabled selected>Loading Libraries...</option>
            </select>
        </div>

        <div class="visibility-options">
            <span class="visibility-label">Visible on:</span>
            <label class="visibility-check"><input type="checkbox" id="import-visibility-home" checked> Home</label>
            <label class="visibility-check"><input type="checkbox" id="import-visibility-library" checked> Library</label>
            <label class="visibility-check"><input type="checkbox" id="import-visibility-friends"> Friends</label>
        </div>
        
        <button onclick="analyzeList()" id="analyze-btn" class="btn-analyze">üîç Analyze & Match</button>
        
        <div id="import-results" class="import-results-container"></div>
        
        <button onclick="createImportedCollection()" id="create-import-btn" class="btn-create-import">‚úÖ Create Collection</button>
    </div>
</div>

<script>
const API_SAVE_SCHEDULE_TIME = "{{ url_for('api.save_schedule_time') }}";
function saveGlobalTime() {
    const t = document.getElementById('globalTime').value;
    const feedback = document.getElementById('save-time-feedback');
    fetch(API_SAVE_SCHEDULE_TIME, {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded', 'X-CSRFToken': '{{ csrf_token() }}'},
        body: 'time=' + encodeURIComponent(t)
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            if (feedback) { feedback.style.display = 'inline'; feedback.textContent = 'Saved'; setTimeout(() => { feedback.style.display = 'none'; }, 2500); }
        } else {
            alert(data.message || 'Could not save time');
        }
    })
    .catch(() => alert('Could not save schedule time'));
}
</script>

{% if custom_presets %}
<div class="category-block category-block--collapsed" data-type="any">
    <button type="button" class="category-header category-header--toggle" aria-expanded="false" aria-controls="custom-collections-grid">
        <span class="category-chevron" aria-hidden="true">‚ñ∂</span>
        Your Custom Collections
    </button>
    <div id="custom-collections-grid" class="playlist-grid category-grid" hidden>
    {% for key, playlist in custom_presets.items() %}
    <div class="card playlist-card" data-type="{{ playlist.media_type }}">
        <div>
            <div class="playlist-header-row">
                <div class="playlist-icon">{% if 'Imported' in playlist.description %}üìã{% else %}üõ†Ô∏è{% endif %}</div>
                <button onclick="deleteCollection('{{ key }}', event)" class="btn-delete">Delete üóëÔ∏è</button>
            </div>
            <h3 class="playlist-title">{{ playlist.title }}</h3>
            <p class="playlist-desc">{{ playlist.description }}</p>
        </div>
        
        <div class="playlist-controls">
            {% if 'Imported' not in playlist.description %}
            <div class="playlist-control-section">
                <div class="control-row">
                    <label>Auto-Update</label>
                    <select id="freq-{{ key }}" onchange="saveSettings('{{ key }}')" class="control-select">
                        <option value="manual" {% if schedules.get(key) == 'manual' %}selected{% endif %}>Off</option>
                        <option value="daily" {% if schedules.get(key) == 'daily' %}selected{% endif %}>Daily</option>
                        <option value="weekly" {% if schedules.get(key) == 'weekly' %}selected{% endif %}>Weekly</option>
                    </select>
                </div>
                <div class="control-row">
                    <label class="control-label-with-tip">
                        Sync Mode
                        <span class="tooltip-container">
                            <span class="info-icon" aria-label="Help">‚ÑπÔ∏è</span>
                            <span class="tooltip-text"><strong>Sync (Strict):</strong> Adds and removes to match the list.<br><strong>Append:</strong> Only adds, never removes.</span>
                        </span>
                    </label>
                    {% set sm = (sync_modes or {}).get(key, 'append') %}
                    <select id="sync-{{ key }}" onchange="saveSettings('{{ key }}')" class="control-select">
                        <option value="append" {% if sm == 'append' %}selected{% endif %}>Append (Grow)</option>
                        <option value="sync" {% if sm == 'sync' %}selected{% endif %}>Sync (Strict)</option>
                    </select>
                </div>
            </div>
            <div class="playlist-control-section">
                <div class="visibility-label-block">Where it appears in Plex</div>
                <div class="visibility-checks-row">
                    <label class="visibility-check"><input type="checkbox" id="visibility-home-{{ key }}" onchange="saveSettings('{{ key }}')" {% if playlist.get('visibility_home', True) %}checked{% endif %}> Home</label>
                    <label class="visibility-check"><input type="checkbox" id="visibility-library-{{ key }}" onchange="saveSettings('{{ key }}')" {% if playlist.get('visibility_library', True) %}checked{% endif %}> Library recommended</label>
                    <label class="visibility-check"><input type="checkbox" id="visibility-friends-{{ key }}" onchange="saveSettings('{{ key }}')" {% if playlist.get('visibility_friends') %}checked{% endif %}> Friends</label>
                </div>
                <p class="visibility-hint">Check at least one. In Plex: <strong>Settings -> Manage -> Libraries</strong>, then <strong>Manage Recommendations</strong> to reorder or change where collections appear.</p>
            </div>
            <div class="playlist-control-section playlist-control-section--actions">
                <button onclick="previewCollection('{{ key }}', '{{ playlist.title|replace("'", "\\'") }}')" class="btn-preview" title="Preview Contents">üëÄ</button>
                <button onclick="createCollection('{{ key }}')" id="btn-{{ key }}" class="btn-sync">Sync Now</button>
            </div>
            {% else %}
            <div class="static-badge">Static Import</div>
            <button disabled class="btn-synced-disabled">Synced ‚úÖ</button>
            {% endif %}
        </div>
    </div>
    {% endfor %}
    </div>
</div>
{% endif %}

{% set categories = ['Regional Trending', 'International & World', 'Decades', 'Themes & Vibes', 'Awards & Acclaim', 'Studios & Networks', 'Genre (Movies)', 'Genre (TV)', 'Content Ratings'] %}

{% for cat in categories %}
{% set cat_id = cat|replace(' ', '-')|replace('&', '')|replace('(', '')|replace(')', '') %}
<div class="category-block category-block--collapsed playlist-section" data-cat="{{ cat }}">
    <button type="button" class="category-header category-header--toggle" aria-expanded="false" aria-controls="cat-{{ cat_id }}">
        <span class="category-chevron" aria-hidden="true">‚ñ∂</span>
        {{ cat }}
    </button>
    <div id="cat-{{ cat_id }}" class="playlist-grid category-grid" hidden>
    {% for key, playlist in presets.items() %}
    {% if playlist.category == cat %}
    <div class="card playlist-card" data-type="{{ playlist.media_type }}">
        <div>

            <h3 class="playlist-title">{{ playlist.title }}</h3>
            <p class="playlist-desc">{{ playlist.description }}</p>
        </div>
        
        <div class="playlist-controls">
            <div class="playlist-control-section">
                <div class="control-row">
                    <label>Auto-Update</label>
                    <select id="freq-{{ key }}" onchange="saveSettings('{{ key }}')" class="control-select">
                        <option value="manual" {% if schedules.get(key) == 'manual' or (schedules.get(key) is none and playlist.category != 'Regional Trending') %}selected{% endif %}>Off</option>
                        <option value="daily" {% if schedules.get(key) == 'daily' or (schedules.get(key) is none and playlist.category == 'Regional Trending') %}selected{% endif %}>Daily</option>
                        <option value="weekly" {% if schedules.get(key) == 'weekly' %}selected{% endif %}>Weekly</option>
                    </select>
                </div>
                <div class="control-row">
                    <label class="control-label-with-tip">
                        Sync Mode
                        {% if 'Trending' not in playlist.title %}
                        <span class="tooltip-container">
                            <span class="info-icon" aria-label="Help">‚ÑπÔ∏è</span>
                            <span class="tooltip-text"><strong>Sync (Strict):</strong> Adds and removes to match the list.<br><strong>Append:</strong> Only adds, never removes.</span>
                        </span>
                        {% endif %}
                    </label>
                    {% if 'Trending' in playlist.title or 'Trending' in playlist.category %}
                        <input type="hidden" id="sync-{{ key }}" value="sync">
                        <div class="locked-badge">üîí Strict Sync</div>
                    {% else %}
                        {% set sm = (sync_modes or {}).get(key, 'append') %}
                        <select id="sync-{{ key }}" onchange="saveSettings('{{ key }}')" class="control-select">
                            <option value="append" {% if sm == 'append' %}selected{% endif %}>Append (Grow)</option>
                            <option value="sync" {% if sm == 'sync' %}selected{% endif %}>Sync (Strict)</option>
                        </select>
                    {% endif %}
                </div>
            </div>

            {% set vis = (visibility or {}).get(key, {}) %}
            <div class="playlist-control-section">
                <div class="visibility-label-block">Where it appears in Plex</div>
                <div class="visibility-checks-row">
                    <label class="visibility-check"><input type="checkbox" id="visibility-home-{{ key }}" onchange="saveSettings('{{ key }}')" {% if vis.get('home', True) %}checked{% endif %}> Home</label>
                    <label class="visibility-check"><input type="checkbox" id="visibility-library-{{ key }}" onchange="saveSettings('{{ key }}')" {% if vis.get('library', True) %}checked{% endif %}> Library recommended</label>
                    <label class="visibility-check"><input type="checkbox" id="visibility-friends-{{ key }}" onchange="saveSettings('{{ key }}')" {% if vis.get('friends') %}checked{% endif %}> Friends</label>
                </div>
                <p class="visibility-hint">Check at least one. In Plex: <strong>Settings -> Manage -> Libraries</strong>, then <strong>Manage Recommendations</strong> to reorder or change where collections appear.</p>
            </div>

            <div class="playlist-control-section playlist-control-section--actions">
                <button onclick="previewCollection('{{ key }}', '{{ playlist.title|replace("'", "\\'") }}')" class="btn-preview" title="Preview Contents">üëÄ</button>
                <button onclick="createCollection('{{ key }}')" id="btn-{{ key }}" class="btn-sync">Run Now</button>
                {% if schedules.get(key) is not none %}
                <button onclick="deleteCollection('{{ key }}', event)" class="btn-delete-inline" title="Remove from app and Plex">Delete</button>
                {% endif %}
            </div>
        </div>
    </div>
    {% endif %}
    {% endfor %}
    </div>
</div>
{% endfor %}

<script>
const API_GET_CACHE_STATUS = "{{ url_for('api.get_cache_status_route') }}";
const API_GET_PLEX_COLLECTIONS = "{{ url_for('api.get_plex_collections') }}";
const API_PLEX_COLLECTION_VISIBILITY = "{{ url_for('api.set_plex_collection_visibility') }}";
const API_GET_PLEX_LIBRARIES = "{{ url_for('api.get_plex_libraries') }}";
const API_PREVIEW_PRESET_ITEMS_BASE = "{{ url_for('api.preview_preset_items', key='') }}";
const API_CREATE_COLLECTION_BASE = "{{ url_for('api.create_collection', key='') }}";
const API_DELETE_COLLECTION_BASE = "{{ url_for('api.delete_collection', key='') }}";
const API_SCHEDULE_COLLECTION = "{{ url_for('api.schedule_collection') }}";
const API_MATCH_BULK_TITLES = "{{ url_for('api.match_bulk_titles') }}";
const API_CREATE_BULK_COLLECTION = "{{ url_for('api.create_bulk_collection') }}";

function openTab(evt, tabName) {
        // Hide every tab panel first.
        var tabcontent = document.getElementsByClassName("tab-content");
        for (var i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
            tabcontent[i].classList.remove("active");
        }
        
        // Clear active state on tabs.
        var tablinks = document.getElementsByClassName("tab-btn");
        for (var i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }
        
        // Show selected tab and mark it active.
        document.getElementById(tabName).style.display = "block";
        // Small delay so the transition has a frame to kick in.
        setTimeout(() => document.getElementById(tabName).classList.add("active"), 10);
        evt.currentTarget.classList.add("active");
    }

    // Live collections viewer
    let viewerLoaded = false;
    function refreshLibraryBrowser() {
        viewerLoaded = false;
        document.getElementById('viewer-loading').style.display = 'block';
        document.getElementById('viewer-grid').style.display = 'none';
        document.getElementById('viewer-grid').innerHTML = '';
        loadLiveCollections();
    }
    function loadLiveCollections() {
        if(viewerLoaded) return; // Avoid repeat API calls.
        
        fetch(API_GET_PLEX_COLLECTIONS)
        .then(r => r.json())
        .then(data => {
            document.getElementById('viewer-loading').style.display = 'none';
            const grid = document.getElementById('viewer-grid');
            grid.style.display = 'grid';
            
            if(data.status === 'success' && data.collections.length > 0) {
                let html = '';
                data.collections.forEach(c => {
                    const thumb = (c.thumb && (c.thumb.startsWith('http://') || c.thumb.startsWith('https://'))) ? c.thumb : 'https://via.placeholder.com/200x300?text=No+Art';
                    const url = (c.url && (c.url.startsWith('http://') || c.url.startsWith('https://'))) ? c.url : '#';
                    const keyPath = escapeHtml(String(c.keyPath || c.key || ''));
                    const home = !!c.visible_home;
                    const lib = !!c.visible_library;
                    const friends = !!c.visible_friends;
                    html += `
                    <div class="viewer-card" data-url="${escapeHtml(url)}" role="button" tabindex="0">
                        <img src="${escapeHtml(thumb)}" style="width:100%; height:100%; object-fit:cover;" alt="">
                        <div class="viewer-badge">${escapeHtml(String(c.count || ''))}</div>
                        <div class="viewer-info">
                            <div style="font-weight:bold; color:white; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(String(c.title || ''))}</div>
                            <div style="font-size:0.8em; color:#ccc;">${escapeHtml(String(c.library || ''))}</div>
                            <div class="viewer-visibility" onclick="event.stopPropagation();">
                                <label class="viewer-check"><input type="checkbox" class="viewer-check-home" data-keypath="${keyPath}" ${home ? 'checked' : ''}> Home</label>
                                <label class="viewer-check"><input type="checkbox" class="viewer-check-library" data-keypath="${keyPath}" ${lib ? 'checked' : ''}> Library</label>
                                <label class="viewer-check"><input type="checkbox" class="viewer-check-friends" data-keypath="${keyPath}" ${friends ? 'checked' : ''}> Friends</label>
                            </div>
                        </div>
                    </div>`;
                });
                grid.innerHTML = html;
                // open collection URL on click (delegated; only allow http(s))
                grid.querySelectorAll('.viewer-card').forEach(card => {
                    card.addEventListener('click', function(e) {
                        if (e.target.closest('.viewer-visibility')) return;
                        const u = this.getAttribute('data-url');
                        if (u && u !== '#' && (u.startsWith('http://') || u.startsWith('https://'))) window.open(u, '_blank');
                    });
                });
                // save visibility when tickboxes change (same three columns as Plex Manage Recommendations)
                grid.querySelectorAll('.viewer-check-home, .viewer-check-library, .viewer-check-friends').forEach(el => {
                    el.addEventListener('change', function() {
                        const keyPath = this.getAttribute('data-keypath');
                        if (!keyPath) return;
                        const card = this.closest('.viewer-card');
                        const homeEl = card.querySelector('.viewer-check-home');
                        const libEl = card.querySelector('.viewer-check-library');
                        const friendsEl = card.querySelector('.viewer-check-friends');
                        const visible_home = homeEl ? homeEl.checked : true;
                        const visible_library = libEl ? libEl.checked : true;
                        const visible_friends = friendsEl ? friendsEl.checked : false;
                        fetch(API_PLEX_COLLECTION_VISIBILITY, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token() }}' },
                            body: JSON.stringify({ keyPath: keyPath, visible_home: visible_home, visible_library: visible_library, visible_friends: visible_friends })
                        }).then(r => r.json()).then(data => {
                            if (data.status !== 'success') {
                                alert(data.message || 'Could not update visibility');
                            } else if (data.message) {
                                const banner = document.createElement('div');
                                banner.className = 'viewer-save-banner';
                                banner.textContent = data.message;
                                grid.insertBefore(banner, grid.firstChild);
                                setTimeout(() => banner.remove(), 8000);
                            }
                        }).catch(() => alert('Request failed'));
                    });
                });
                viewerLoaded = true;
            } else {
                grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:50px; color:#666;">No collections found. Make sure you have at least one Movie or TV library in Plex with collections. If you just created some, try <strong>Refresh list</strong> above.</div>';
            }
        })
        .catch(() => {
            const loader = document.getElementById('viewer-loading');
            const grid = document.getElementById('viewer-grid');
            if (loader) loader.style.display = 'none';
            if (grid) { grid.style.display = 'grid'; grid.innerHTML = '<div style="grid-column:1/-1; text-align:center; padding:50px; color:#e74c3c;">Failed to load collections. Check Plex connection in Settings and try <strong>Refresh list</strong>.</div>'; }
        });
    }
// Check cache lockout so we don't fire while busy.
setInterval(checkCacheStatus, 2000); 

function checkCacheStatus() {
    fetch(API_GET_CACHE_STATUS).then(r => r.json()).then(data => {
        const btns = document.querySelectorAll('.btn-sync');
        const importBtn = document.getElementById('btn-import-open');
        const builderBtn = document.getElementById('btn-builder-nav');
        
        if(data.running) {
            btns.forEach(b => {
                b.disabled = true; b.innerText = "System Busy ‚è≥"; 
                b.style.opacity = "0.5"; b.style.cursor = "not-allowed";
            });
            if(importBtn) { importBtn.disabled = true; importBtn.style.opacity = "0.5"; }
            if(builderBtn) { builderBtn.disabled = true; builderBtn.style.opacity = "0.5"; }
        } else {
            btns.forEach(b => {
                if(b.disabled && b.innerText.includes("System Busy")) {
                    b.disabled = false;
                    b.style.opacity = "1";
                    b.style.cursor = "pointer";
                    b.innerText = (b.id && b.id.startsWith("btn-custom")) ? "Sync Now" : "Run Now";
                }
            });
            if(importBtn) { importBtn.disabled = false; importBtn.style.opacity = "1"; }
            if(builderBtn) { builderBtn.disabled = false; builderBtn.style.opacity = "1"; }
        }
    });
}

const PLAYLISTS_TYPE_KEY = 'seekandwatch_playlists_type';

// Filter cards by media type.
function filterType(type) {
    if (type !== 'movie' && type !== 'tv') type = 'movie';
    try { localStorage.setItem(PLAYLISTS_TYPE_KEY, type); } catch (e) {}
    document.getElementById('btn-movie').classList.remove('active');
    document.getElementById('btn-tv').classList.remove('active');
    document.getElementById('btn-' + type).classList.add('active');
    const cards = document.querySelectorAll('.playlist-card');
    cards.forEach(card => {
        card.style.display = (card.dataset.type === type) ? 'flex' : 'none';
    });
    const blocks = document.querySelectorAll('.category-block');
    blocks.forEach(block => {
        const grid = block.querySelector('.playlist-grid');
        if (!grid) return;
        let hasVisible = false;
        grid.querySelectorAll('.playlist-card').forEach(c => { if (c.style.display !== 'none') hasVisible = true; });
        block.style.display = hasVisible ? '' : 'none';
        const header = block.querySelector('.category-header');
        if (header) header.style.display = hasVisible ? 'flex' : 'none';
    });
    restoreOpenCategories();
}

// persist which category dropdowns are open per tab (Movies vs TV) so refresh / run list keeps them dropped down
function getCurrentFilter() {
    const btn = document.querySelector('.type-toggle-btn.active');
    return (btn && btn.id === 'btn-tv') ? 'tv' : 'movie';
}

function saveOpenCategories() {
    const filter = getCurrentFilter();
    const open = [];
    document.querySelectorAll('.category-block').forEach(block => {
        const grid = block.querySelector('.playlist-grid');
        if (!grid || !grid.id) return;
        if (!block.classList.contains('category-block--collapsed')) open.push(grid.id);
    });
    try { sessionStorage.setItem('playlist-open-categories-' + filter, JSON.stringify(open)); } catch (e) {}
}

function restoreOpenCategories() {
    const filter = getCurrentFilter();
    try {
        const raw = sessionStorage.getItem('playlist-open-categories-' + filter);
        if (!raw) return;
        const open = JSON.parse(raw);
        if (!Array.isArray(open) || open.length === 0) return;
        document.querySelectorAll('.category-block').forEach(block => {
            const grid = block.querySelector('.playlist-grid');
            const header = block.querySelector('.category-header--toggle');
            const chevron = block.querySelector('.category-chevron');
            if (!grid || !grid.id || open.indexOf(grid.id) === -1) return;
            block.classList.remove('category-block--collapsed');
            grid.hidden = false;
            grid.style.display = 'grid';
            if (header) header.setAttribute('aria-expanded', 'true');
            if (chevron) chevron.textContent = '‚ñº';
        });
    } catch (e) {}
}

// Collapsible category sections (minimized by default, click header to expand).
function initCategoryToggles() {
    document.querySelectorAll('.category-header--toggle').forEach(btn => {
        btn.addEventListener('click', function() {
            const block = this.closest('.category-block');
            const grid = block && block.querySelector('.playlist-grid');
            if (!block || !grid) return;
            const isCollapsed = block.classList.toggle('category-block--collapsed');
            grid.hidden = isCollapsed;
            grid.style.display = isCollapsed ? 'none' : 'grid';
            this.setAttribute('aria-expanded', !isCollapsed);
            const chevron = this.querySelector('.category-chevron');
            if (chevron) chevron.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
            saveOpenCategories();
        });
    });
}

document.addEventListener('DOMContentLoaded', () => {
    let savedType = 'movie';
    try { savedType = localStorage.getItem(PLAYLISTS_TYPE_KEY) || 'movie'; } catch (e) {}
    if (savedType !== 'movie' && savedType !== 'tv') savedType = 'movie';
    filterType(savedType);
    restoreOpenCategories();
    initCategoryToggles();
});

// Preview modal
function previewCollection(key, title) {
    document.getElementById('preview-title').innerText = "üëÄ " + title;
    const grid = document.getElementById('preview-grid');
    grid.innerHTML = '<div style="text-align:center; grid-column:1/-1; padding:20px; color:#aaa;">Loading live data from TMDB...</div>';
    document.getElementById('preview-modal').style.display = 'block';
    document.body.style.overflow = 'hidden';
    
    const previewController = new AbortController();
    const previewTimeout = setTimeout(() => previewController.abort(), 15000);
    fetch(API_PREVIEW_PRESET_ITEMS_BASE + encodeURIComponent(key), { signal: previewController.signal })
    .then(r => r.json())
    .then(data => {
        clearTimeout(previewTimeout);
        if(data.status === 'success') {
            let html = '';
            data.items.forEach(item => {
                const opacity = item.owned ? '1' : '0.6';
                const status = item.owned ? '‚úÖ Owned' : 'missing';
                const poster = item.poster_path ? 'https://image.tmdb.org/t/p/w200' + item.poster_path : 'https://via.placeholder.com/200x300?text=No+Poster';
                html += `<div class="preview-item" style="opacity: ${opacity};">
                    <img src="${escapeHtml(poster)}" class="preview-poster" alt="">
                    <div class="preview-title">${escapeHtml(String(item.title || ''))}</div>
                    <div class="preview-meta">${escapeHtml(String(item.year || ''))} ‚Ä¢ ${escapeHtml(String(status || ''))}</div>
                </div>`;
            });
            grid.innerHTML = html;
        } else {
            grid.innerHTML = `<div style="color:var(--error); grid-column:1/-1; text-align:center;">Error: ${(data.message || 'Unknown error').replace(/</g, '&lt;')}</div>`;
        }
    })
    .catch(() => { clearTimeout(previewTimeout); grid.innerHTML = '<div style="color:var(--error); grid-column:1/-1; text-align:center;">Request failed or timed out.</div>'; });
}

function closePreviewModal() {
    const modal = document.getElementById('preview-modal');
    if (modal) { modal.style.display = 'none'; document.body.style.overflow = ''; }
}

// Delete a collection (from app and Plex). Returns fast; Plex delete runs in background to avoid slow click handler.
function deleteCollection(key, ev) {
    if (!confirm("Delete this collection from the app and from Plex?")) return;
    const btn = (ev && ev.target) ? ev.target : null;
    if (btn) { btn.disabled = true; btn.textContent = 'Deleting‚Ä¶'; }
    fetch(API_DELETE_COLLECTION_BASE + encodeURIComponent(key), {
        method: 'POST',
        headers: { 'X-CSRFToken': '{{ csrf_token() }}' }
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            location.reload();
        } else {
            if (btn) { btn.disabled = false; btn.textContent = 'Delete üóëÔ∏è'; }
            alert(data.message || 'Could not delete collection.');
        }
    })
    .catch(() => {
        if (btn) { btn.disabled = false; btn.textContent = 'Delete üóëÔ∏è'; }
        alert('Request failed. Could not delete collection.');
    });
}

// Legacy name for custom-card delete (same as deleteCollection).
function deleteCustom(key) { deleteCollection(key); }

// Run a preset now. Sends current visibility checkboxes so first run uses them.
function createCollection(key) {
    const btn = document.getElementById('btn-' + key);
    if (!btn) return;
    const originalText = btn.innerText;
    btn.disabled = true; btn.innerText = "Processing... ‚è≥"; btn.style.background = "#555";
    const visHome = document.getElementById('visibility-home-' + key);
    const visLib = document.getElementById('visibility-library-' + key);
    const visFriends = document.getElementById('visibility-friends-' + key);
    const body = JSON.stringify({
        visibility_home: visHome ? visHome.checked : true,
        visibility_library: visLib ? visLib.checked : true,
        visibility_friends: visFriends ? visFriends.checked : false
    });
    const createController = new AbortController();
    const createTimeout = setTimeout(() => createController.abort(), 60000);
    fetch(API_CREATE_COLLECTION_BASE + encodeURIComponent(key), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token() }}' },
        body: body,
        signal: createController.signal
    })
    .then(r => r.json()).then(d => {
        clearTimeout(createTimeout);
        if (d.status === 'success') {
            btn.innerText = "Done! ‚úÖ"; btn.style.background = "#2ecc71"; alert(d.message);
            // Show Delete button without refresh (collection now has a schedule)
            const actionsRow = btn.closest('.playlist-control-section--actions');
            if (actionsRow && !actionsRow.querySelector('.btn-delete-inline')) {
                const delBtn = document.createElement('button');
                delBtn.type = 'button';
                delBtn.className = 'btn-delete-inline';
                delBtn.title = 'Remove from app and Plex';
                delBtn.textContent = 'Delete';
                delBtn.onclick = function(ev) { deleteCollection(key, ev); };
                actionsRow.appendChild(delBtn);
            }
        } else { btn.innerText = "Error ‚ùå"; btn.style.background = "#e74c3c"; alert(d.message); }
        setTimeout(() => { btn.innerText = originalText; btn.disabled = false; btn.style.background = "#333"; }, 3000);
    })
    .catch(() => {
        clearTimeout(createTimeout);
        btn.innerText = originalText; btn.disabled = false; btn.style.background = "#333";
        alert('Request failed or timed out. Please try again.');
    });
}

// Save schedule settings (frequency + sync mode). When visibility checkboxes change, also push to Plex so it updates without running the collection again.
function saveSettings(key) {
    const freqEl = document.getElementById('freq-' + key);
    const syncEl = document.getElementById('sync-' + key);
    const visHomeEl = document.getElementById('visibility-home-' + key);
    const visLibEl = document.getElementById('visibility-library-' + key);
    const visFriendsEl = document.getElementById('visibility-friends-' + key);
    
    const freq = freqEl ? freqEl.value : 'manual';
    const sync = (syncEl && syncEl.value) ? syncEl.value : 'sync';
    const visibility_home = (visHomeEl && visHomeEl.checked) ? '1' : '0';
    const visibility_library = (visLibEl && visLibEl.checked) ? '1' : '0';
    const visibility_friends = (visFriendsEl && visFriendsEl.checked) ? '1' : '0';
    const visible_home = visHomeEl && visHomeEl.checked;
    const visible_library = visLibEl && visLibEl.checked;
    const visible_friends = visFriendsEl && visFriendsEl.checked;

    fetch(API_SCHEDULE_COLLECTION, {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded', 'X-CSRFToken': '{{ csrf_token() }}'},
        body: `preset_key=${encodeURIComponent(key)}&frequency=${encodeURIComponent(freq)}&sync_mode=${encodeURIComponent(sync)}&visibility_home=${visibility_home}&visibility_library=${visibility_library}&visibility_friends=${visibility_friends}`
    })
    .then(r => r.json())
    .then(data => {
        const fb = document.getElementById('schedule-save-feedback');
        if (data.status === 'success' && fb) {
            fb.textContent = 'Settings saved';
            fb.style.display = 'inline';
            setTimeout(() => { fb.style.display = 'none'; }, 2500);
        } else if (data.message) {
            alert(data.message);
        }
    })
    .catch(() => alert('Could not save settings'));

    // push visibility to Plex immediately so the collection's Home/Library/Friends toggles update without running the collection again
    fetch(API_PLEX_COLLECTION_VISIBILITY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token() }}' },
        body: JSON.stringify({ preset_key: key, visible_home: visible_home, visible_library: visible_library, visible_friends: visible_friends })
    }).then(r => r.json()).then(data => {
        if (data.status !== 'success' && data.message && !data.message.includes('Collection not found')) {
            console.warn('Visibility update:', data.message);
        }
    }).catch(() => {});
}

// Import modal
let matchedKeys = [];
function openImportModal() { document.getElementById('import-modal').style.display = 'block'; document.body.style.overflow = 'hidden'; fetchLibraries(); }
function closeImportModal() { document.getElementById('import-modal').style.display = 'none'; document.body.style.overflow = 'auto'; }

function fetchLibraries() {
    fetch(API_GET_PLEX_LIBRARIES).then(r => r.json()).then(data => {
        const select = document.getElementById('import-library');
        if (!select) return;
        if(data.status === 'success') {
            let html = '';
            data.libraries.forEach(lib => {
                const icon = lib.type === 'movie' ? 'üé¨' : 'üì∫';
                html += `<option value="${lib.title}">${icon} ${lib.title}</option>`;
            });
            select.innerHTML = html;
        } else { select.innerHTML = '<option disabled>Error fetching libraries</option>'; }
    }).catch(() => { const s = document.getElementById('import-library'); if (s) s.innerHTML = '<option disabled>Failed to load libraries</option>'; });
}

function analyzeList() {
    const text = document.getElementById('import-text').value;
    const library = document.getElementById('import-library').value;
    const btn = document.getElementById('analyze-btn');
    if(!text.trim()) { alert("Paste some titles first!"); return; }
    if(!library) { alert("Select a library!"); return; }
    
    btn.innerText = "Analyzing... ‚è≥"; btn.disabled = true;
    
    const analyzeController = new AbortController();
    const analyzeTimeout = setTimeout(() => analyzeController.abort(), 60000);
    fetch(API_MATCH_BULK_TITLES, {
        method: 'POST', headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({titles: text, target_library: library}),
        signal: analyzeController.signal
    }).then(res => res.json()).then(data => {
        clearTimeout(analyzeTimeout);
        btn.innerText = "üîç Analyze & Match"; btn.disabled = false;
        if(data.status === 'success') {
            const resDiv = document.getElementById('import-results');
            resDiv.style.display = 'block';
            let html = '<table class="result-table">';
            matchedKeys = [];
            data.results.forEach(r => {
                const statusClass = r.found ? 'status-found' : 'status-missing';
                const statusText = r.found ? '‚úÖ Found' : '‚ùå Missing';
                if(r.found) matchedKeys.push(r.key);
                html += `<tr class="result-row"><td class="result-cell query">${r.query}</td><td class="result-cell">${r.title}</td><td class="result-cell ${statusClass}">${statusText}</td></tr>`;
            });
            html += '</table>';
            resDiv.innerHTML = html;
            if(matchedKeys.length > 0) {
                document.getElementById('create-import-btn').style.display = 'block';
                document.getElementById('create-import-btn').innerText = `‚úÖ Create Collection (${matchedKeys.length} items)`;
            }
        }
    }).catch(() => {
        clearTimeout(analyzeTimeout);
        btn.innerText = "üîç Analyze & Match"; btn.disabled = false;
        alert('Request failed or timed out. Please try again.');
    });
}

function createImportedCollection() {
    const title = document.getElementById('import-title').value;
    const library = document.getElementById('import-library').value;
    if(!title) { alert("Please name your collection!"); return; }
    const payload = {
        collection_title: title,
        rating_keys: matchedKeys,
        target_library: library,
        visibility_home: document.getElementById('import-visibility-home').checked,
        visibility_library: document.getElementById('import-visibility-library').checked,
        visibility_friends: document.getElementById('import-visibility-friends').checked
    };
    fetch(API_CREATE_BULK_COLLECTION, {
        method: 'POST', headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
    }).then(res => res.json()).then(data => {
        if(data.status === 'success') { alert(data.message); closeImportModal(); location.reload(); } 
        else { alert(data.message); }
    }).catch(() => alert('Request failed. Please try again.'));
}

document.addEventListener('keydown', function(e) {
    if (e.key !== 'Escape') return;
    const preview = document.getElementById('preview-modal');
    const importModal = document.getElementById('import-modal');
    if (preview && preview.style.display === 'block') closePreviewModal();
    else if (importModal && importModal.style.display === 'block') closeImportModal();
});
</script>
{% endblock %}