{% extends "base.html" %}
{% block page_title %}Media{% endblock %}
{% block content %}

<div class="media-container">
    <div class="media-header">
        <h2>Media Management</h2>
        <p class="text-muted">View and manage your requested, monitored, and downloaded media across Overseerr, Radarr, and Sonarr.</p>
    </div>

    <!-- Requested Tab -->
    <div id="tab-requested" class="media-tab-content active">
        {% if not settings.overseerr_url or not settings.overseerr_api_key %}
        <div class="card setting-card" style="text-align: center; padding: 40px;">
            <h3>‚ö†Ô∏è Overseerr Not Configured</h3>
            <p>Please add your Overseerr URL and API key in <a href="{{ url_for('settings') }}">Settings</a> to view requested media.</p>
        </div>
        {% else %}
        <div class="media-filters">
            <div class="filter-row">
                <select id="filter-status" class="filter-select" onchange="loadMediaData()">
                    <option value="">All Statuses</option>
                    <option value="pending">Pending</option>
                    <option value="approved">Approved</option>
                    <option value="available">Available</option>
                    <option value="failed">Failed</option>
                </select>
                <select id="filter-source" class="filter-select" onchange="loadMediaData()">
                    <option value="">All Sources</option>
                    <option value="overseerr">Overseerr</option>
                    <option value="manual">Manual</option>
                </select>
                <select id="sort-by" class="filter-select" onchange="loadMediaData()">
                    <option value="added_desc">Recently Added</option>
                    <option value="title_asc">Title (A-Z)</option>
                    <option value="year_desc">Year (Newest)</option>
                </select>
                <select id="page-size-requested" class="filter-select" onchange="loadMediaData()">
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="150">150</option>
                    <option value="200" selected>200</option>
                </select>
            </div>
        </div>
        <div id="requested-table-container" class="media-poster-grid-container">
            <div style="text-align: center; padding: 40px; color: #888;">Loading requested media...</div>
        </div>
        {% endif %}
    </div>

    <!-- Movies Tab -->
    <div id="tab-movies" class="media-tab-content">
        {% if not settings.radarr_url or not settings.radarr_api_key %}
        <div class="card setting-card" style="text-align: center; padding: 40px;">
            <h3>‚ö†Ô∏è Radarr Not Configured</h3>
            <p>Please add your Radarr URL and API key in <a href="{{ url_for('settings') }}">Settings</a> to view movies.</p>
        </div>
        {% else %}
        <div class="media-filters">
            <div class="filter-row">
                <select id="filter-monitored-movies" class="filter-select" onchange="loadMediaData()">
                    <option value="">All</option>
                    <option value="monitored">Monitored</option>
                    <option value="unmonitored">Unmonitored</option>
                </select>
                <select id="filter-has-file-movies" class="filter-select" onchange="loadMediaData()">
                    <option value="">All</option>
                    <option value="has_file">Has File</option>
                    <option value="missing_file">Missing File</option>
                </select>
                <select id="sort-by-movies" class="filter-select" onchange="loadMediaData()">
                    <option value="added_desc">Recently Added</option>
                    <option value="title_asc">Title (A-Z)</option>
                    <option value="year_desc">Year (Newest)</option>
                    <option value="size_desc">Size (Largest)</option>
                </select>
                <select id="page-size-movies" class="filter-select" onchange="loadMediaData()">
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="150">150</option>
                    <option value="200" selected>200</option>
                </select>
            </div>
        </div>
        <div id="movies-table-container" class="media-table-container">
            <div style="text-align: center; padding: 40px; color: #888;">Loading movies...</div>
        </div>
        <div id="movies-detail-container" class="media-detail-container" style="display: none;">
            <!-- Detail view will be rendered here -->
        </div>
        {% endif %}
    </div>

    <!-- TV Shows Tab -->
    <div id="tab-tv" class="media-tab-content">
        {% if not settings.sonarr_url or not settings.sonarr_api_key %}
        <div class="card setting-card" style="text-align: center; padding: 40px;">
            <h3>‚ö†Ô∏è Sonarr Not Configured</h3>
            <p>Please add your Sonarr URL and API key in <a href="{{ url_for('settings') }}">Settings</a> to view TV shows.</p>
        </div>
        {% else %}
        <div class="media-filters">
            <div class="filter-row">
                <select id="filter-monitored-tv" class="filter-select" onchange="loadMediaData()">
                    <option value="">All</option>
                    <option value="monitored">Monitored</option>
                    <option value="unmonitored">Unmonitored</option>
                </select>
                <select id="filter-has-file-tv" class="filter-select" onchange="loadMediaData()">
                    <option value="">All</option>
                    <option value="has_file">Has File</option>
                    <option value="missing_file">Missing File</option>
                </select>
                <select id="sort-by-tv" class="filter-select" onchange="loadMediaData()">
                    <option value="added_desc">Recently Added</option>
                    <option value="title_asc">Title (A-Z)</option>
                    <option value="year_desc">Year (Newest)</option>
                    <option value="size_desc">Size (Largest)</option>
                </select>
                <select id="page-size-tv" class="filter-select" onchange="loadMediaData()">
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="150">150</option>
                    <option value="200" selected>200</option>
                </select>
            </div>
        </div>
        <div id="tv-table-container" class="media-table-container">
            <div style="text-align: center; padding: 40px; color: #888;">Loading TV shows...</div>
        </div>
        <div id="tv-detail-container" class="media-detail-container" style="display: none;">
            <!-- Detail view will be rendered here -->
        </div>
        {% endif %}
    </div>
</div>

<style>
.media-container { max-width: 1400px; margin: 0 auto; }
.media-header { margin-bottom: 30px; }
.media-tab-content { display: none; }
.media-tab-content.active { display: block; }
.media-filters { margin-bottom: 15px; }
.filter-row { display: flex; gap: 8px; flex-wrap: nowrap; align-items: center; }
.filter-select { padding: 6px 10px; background: #111; border: 1px solid #444; color: white; border-radius: 4px; flex: 1 1 auto; min-width: 0; font-size: 0.9em; cursor: pointer; transition: border-color 0.2s; }
.filter-select:hover { border-color: #666; }
.filter-select:focus { outline: none; border-color: var(--accent-color); }
.media-table-container { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 15px; }
.media-detail-container { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 20px; }
.media-table { width: 100%; border-collapse: collapse; }
.media-table th { text-align: left; padding: 12px; border-bottom: 2px solid #333; color: var(--accent-color); font-weight: bold; }
.media-table td { padding: 12px; border-bottom: 1px solid #333; }
.media-table tr:hover { background: rgba(255,255,255,0.05); }
.status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.85em; font-weight: bold; }
.status-pending { background: #f39c12; color: #000; }
.status-approved { background: #3498db; color: #fff; }
.status-available { background: #2ecc71; color: #fff; }
.status-failed { background: #e74c3c; color: #fff; }
.monitored-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.85em; }
.monitored-yes { background: #2ecc71; color: #fff; }
.monitored-no { background: #95a5a6; color: #fff; }
.action-btn { padding: 4px 8px; margin: 0 2px; border: 1px solid #555; background: #222; color: #fff; border-radius: 4px; cursor: pointer; font-size: 0.85em; position: relative; }
.action-btn:hover { background: #333; border-color: var(--accent-color); }
/* Tooltip styling - ensure tooltips are visible */
.action-btn[title]:hover::after {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.9);
    color: #fff;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 0.75em;
    white-space: nowrap;
    z-index: 1000;
    margin-bottom: 5px;
    pointer-events: none;
}
.search-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
.search-modal-content { background: #111; margin: 2% auto; padding: 20px; border: 1px solid #333; border-radius: 8px; width: 95%; max-width: 1400px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; }
.search-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
.search-modal-header h3 { margin: 0; color: var(--accent-color); }
.search-modal-close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
.search-modal-close:hover { color: #fff; }

/* episode detail modal (same overlay pattern as search) */
.episode-detail-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); }
.episode-detail-modal-content { background: #111; margin: 2% auto; padding: 20px; border: 1px solid #333; border-radius: 8px; width: 95%; max-width: 800px; max-height: 90vh; overflow: auto; }
.episode-detail-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
.episode-detail-modal-header h3 { margin: 0; color: var(--accent-color); font-size: 1.1em; }
.episode-detail-close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
.episode-detail-close:hover { color: #fff; }
.release-item { padding: 12px; margin: 8px 0; background: #1a1a1a; border: 1px solid #333; border-radius: 4px; }
.release-item:hover { background: #222; border-color: var(--accent-color); }
.release-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
.release-title { font-weight: bold; color: #fff; }
.release-size { color: #888; font-size: 0.9em; }
.release-info { display: flex; gap: 15px; flex-wrap: wrap; font-size: 0.85em; color: #aaa; margin-bottom: 8px; }
.release-actions { display: flex; gap: 8px; }

/* Enhanced release table layout */
.releases-table { width: 100%; border-collapse: collapse; font-size: 0.9em; }
.releases-table th { text-align: left; padding: 10px 8px; background: #252525; color: #aaa; font-weight: 600; border-bottom: 2px solid #333; position: sticky; top: 0; z-index: 10; }
.releases-table th:hover { background: #2a2a2a; color: #fff; }
.releases-table td { padding: 10px 8px; border-bottom: 1px solid #2a2a2a; vertical-align: middle; }
.releases-table tr:hover { background: #222; }
.releases-table tr:last-child td { border-bottom: none; }

.source-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.75em; font-weight: 600; }
.source-badge.torrent { background: rgba(0, 204, 102, 0.2); color: #00CC66; border: 1px solid #00CC66; }
.source-badge.usenet { background: rgba(52, 152, 219, 0.2); color: #3498db; border: 1px solid #3498db; }

.peers-good { color: #3498db; }
.peers-low { color: #f39c12; }
.peers-none { color: #e74c3c; }

.rejection-icon { color: #e74c3c; font-size: 1.2em; cursor: help; }
.release-downloaded-icon { color: #2ecc71; font-size: 1.2em; font-weight: bold; cursor: help; }
.custom-format-score { color: #00CC66; font-weight: 600; }
.custom-format-score.zero { color: #888; }

/* inline search results on movie/TV detail page (like main Radarr/Sonarr app) */
.media-detail-search-results { background: #1a1a1a; border-radius: 8px; padding: 16px; border: 1px solid #333; margin-top: 8px; }
.media-detail-search-results-header { margin-bottom: 12px; color: var(--accent-color); font-weight: 600; }
</style>

<!-- Search Modal -->
<div id="searchModal" class="search-modal">
    <div class="search-modal-content">
        <div class="search-modal-header">
            <h3 id="searchModalTitle">Search Results</h3>
            <span class="search-modal-close" onclick="closeSearchModal()">&times;</span>
        </div>
        <div id="searchModalBody" style="flex: 1; overflow: hidden; display: flex; flex-direction: column;">
            <div style="text-align: center; padding: 40px; color: #888;">Loading...</div>
        </div>
    </div>
</div>

<!-- Episode detail modal (Sonarr TV episode details) -->
<div id="episodeDetailModal" class="episode-detail-modal">
    <div class="episode-detail-modal-content">
        <div class="episode-detail-modal-header">
            <h3 id="episodeDetailModalTitle">Episode</h3>
            <span class="episode-detail-close" onclick="closeEpisodeDetailModal()">&times;</span>
        </div>
        <div id="episodeDetailModalBody"></div>
        <div style="margin-top: 15px; text-align: right;">
            <button type="button" class="action-btn" onclick="closeEpisodeDetailModal()" style="padding: 8px 16px;">Close</button>
        </div>
    </div>
</div>

<!-- Detail Modal -->
<!-- Detail views are now rendered inline, modal removed -->

<script>
const API_MEDIA_REQUESTED = "{{ url_for('api.get_requested_media') }}";
const API_MEDIA_MOVIES = "{{ url_for('api.get_movies') }}";
const API_MEDIA_TV = "{{ url_for('api.get_tv_shows') }}";
const API_RADARR_TOGGLE_MONITORED_BASE = "{{ url_for('api.toggle_radarr_monitored', movie_id=0) }}";
const API_SONARR_TOGGLE_MONITORED_BASE = "{{ url_for('api.toggle_sonarr_monitored', series_id=0) }}";
const API_RADARR_SEARCH = "{{ url_for('api.radarr_search') }}";
const API_RADARR_DOWNLOAD = "{{ url_for('api.radarr_download') }}";
const API_SONARR_SEARCH = "{{ url_for('api.sonarr_search') }}";
const API_SONARR_DOWNLOAD = "{{ url_for('api.sonarr_download') }}";
const API_SONARR_MISSING_EPISODES = "{{ url_for('api.sonarr_missing_episodes') }}";
const API_RADARR_MOVIE_BASE = "{{ url_for('api.get_radarr_movie_detail', movie_id=0) }}";
const API_SONARR_SERIES_BASE = "{{ url_for('api.get_sonarr_series_detail', series_id=0) }}";
const API_SONARR_SEARCH_SEASON_BASE = "{{ url_for('api.sonarr_search_season', series_id=0, season_number=0) }}";
const API_SONARR_REFRESH_SEASON_BASE = "{{ url_for('api.sonarr_refresh_season', series_id=0, season_number=0) }}";
const API_SONARR_SEARCH_EPISODE_BASE = "{{ url_for('api.sonarr_search_episode', episode_id=0) }}";
const API_SONARR_REFRESH_EPISODE_BASE = "{{ url_for('api.sonarr_refresh_episode', episode_id=0) }}";
const API_RADARR_REFRESH_BASE = "{{ url_for('api.radarr_refresh_scan', movie_id=0) }}";
const API_RADARR_SEARCH_SCAN_BASE = "{{ url_for('api.radarr_search_scan', movie_id=0) }}";
const API_RADARR_QUEUE_CHECK_BASE = "{{ url_for('api.radarr_queue_check', movie_id=0) }}";
const API_SONARR_REFRESH_BASE = "{{ url_for('api.sonarr_refresh_scan', series_id=0) }}";
const API_SONARR_SEARCH_SCAN_BASE = "{{ url_for('api.sonarr_search_scan', series_id=0) }}";
const API_SONARR_QUEUE_CHECK_BASE = "{{ url_for('api.sonarr_queue_check', series_id=0) }}";
const MEDIA_CSRF = "{{ csrf_token() }}";
let currentTab = 'requested';

function switchMediaTab(evt, tabName) {
    console.log('Switching to tab:', tabName);
    currentTab = tabName;
    const tabContents = document.querySelectorAll('.media-tab-content');
    
    // Hide all tabs
    tabContents.forEach(tab => tab.classList.remove('active'));
    
    // Show the selected tab
    const selectedTab = document.getElementById(`tab-${tabName}`);
    if (selectedTab) {
        selectedTab.classList.add('active');
    }
    
    // Update sidebar active state
    updateSidebarActiveState(tabName);
    
    // Update URL hash
    const hashMap = {
        'requested': '#requested',
        'movies': '#radarr',
        'tv': '#sonarr'
    };
    if (hashMap[tabName]) {
        const newUrl = `${window.location.pathname}${window.location.search}${hashMap[tabName]}`;
        window.history.replaceState({type: 'tab', tab: tabName}, '', newUrl);
    }
    
    loadMediaData();
}

function updateSidebarActiveState(activeTab) {
    // Remove active from all media nav items
    document.querySelectorAll('.media-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Add active to the current tab's sidebar link
    const tabMap = {
        'requested': 'requested',
        'movies': 'radarr',
        'tv': 'sonarr'
    };
    const sidebarTab = tabMap[activeTab];
    if (sidebarTab) {
        const sidebarLink = document.querySelector(`.media-nav-item[data-tab="${activeTab}"]`);
        if (sidebarLink) {
            sidebarLink.classList.add('active');
        }
    }
}


function loadMediaData() {
    // Reset to page 1 when filters or page size change
    const moviesPageEl = document.getElementById('movies-page');
    if (moviesPageEl) {
        moviesPageEl.textContent = '1';
    }
    const tvPageEl = document.getElementById('tv-page');
    if (tvPageEl) {
        tvPageEl.textContent = '1';
    }
    const requestedPageEl = document.getElementById('requested-page');
    if (requestedPageEl) {
        requestedPageEl.textContent = '1';
    }
    
    // Load saved page size preferences from localStorage (in case they were changed elsewhere)
    const savedPageSizeRequested = localStorage.getItem('pageSizeRequested');
    if (savedPageSizeRequested) {
        const select = document.getElementById('page-size-requested');
        if (select) select.value = savedPageSizeRequested;
    }
    
    const savedPageSizeMovies = localStorage.getItem('pageSizeMovies');
    if (savedPageSizeMovies) {
        const select = document.getElementById('page-size-movies');
        if (select) select.value = savedPageSizeMovies;
    }
    
    const savedPageSizeTV = localStorage.getItem('pageSizeTV');
    if (savedPageSizeTV) {
        const select = document.getElementById('page-size-tv');
        if (select) select.value = savedPageSizeTV;
    }
    
    if (currentTab === 'requested') {
        loadRequested();
    } else if (currentTab === 'movies') {
        loadMovies();
    } else if (currentTab === 'tv') {
        loadTV();
    }
}

function loadRequested() {
    const container = document.getElementById('requested-table-container');
    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading...</div>';
    
    const status = document.getElementById('filter-status')?.value || '';
    const source = document.getElementById('filter-source')?.value || '';
    const sort = document.getElementById('sort-by')?.value || 'added_desc';
    const pageSize = document.getElementById('page-size-requested')?.value || '200';
    
    // Get current page from hidden element or default to 1
    const pageElement = document.getElementById('requested-page');
    const page = pageElement ? parseInt(pageElement.textContent || '1') : 1;
    
    // Save page size preference to localStorage
    localStorage.setItem('pageSizeRequested', pageSize);
    
    fetch(API_MEDIA_REQUESTED + '?status=' + encodeURIComponent(status) + '&source=' + encodeURIComponent(source) + '&sort=' + encodeURIComponent(sort) + '&page=' + page + '&page_size=' + pageSize)
        .then(r => r.json())
        .then(data => {
            if (data.status === 'error') {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || ''))}</div>`;
                return;
            }
            
            if (data.items.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No requested media found.</div>';
                return;
            }
            
            let html = '<div class="media-poster-grid">';
            
            data.items.forEach(item => {
                const posterUrl = item.poster_url || '';
                const status = (item.status || '').toString().toLowerCase();
                const statusBarClass = `status-${status.replace(' ', '-')}`;
                const addedDate = item.added ? formatAddedDate(item.added) : 'N/A';
                const mediaTypeIcon = item.media_type === 'tv' ? 'üì∫' : 'üé¨';
                
                html += `<div class="media-poster-card" ${item.overseerr_url ? `onclick="window.open('${item.overseerr_url}', '_blank')" style="cursor: pointer;"` : ''}>
                    <div class="media-poster-image-container">
                        ${posterUrl ? 
                            `<img src="${escapeHtml(posterUrl)}" alt="${escapeHtml(item.title)}" class="media-poster-image" onerror="this.parentElement.innerHTML='<div class=\\'media-poster-image-placeholder\\'>${mediaTypeIcon}</div>'">` :
                            `<div class="media-poster-image-placeholder">${mediaTypeIcon}</div>`
                        }
                    </div>
                    <div class="media-poster-info">
                        <div class="media-poster-title">${escapeHtml(item.title)}</div>
                        <div class="media-poster-status-bar ${statusBarClass}"></div>
                        <div class="media-poster-meta">
                            <div class="media-poster-meta-item">${item.status || 'Unknown'}</div>
                            <div class="media-poster-meta-item">${item.year || 'N/A'}</div>
                            <div class="media-poster-meta-item">Requested: ${addedDate}</div>
                            <div class="media-poster-meta-item">By: ${escapeHtml(item.requested_by || 'N/A')}</div>
                        </div>
                        <div class="media-poster-actions">
                            ${item.overseerr_url ? `<button class="action-btn" onclick="event.stopPropagation(); window.open('${item.overseerr_url}', '_blank')" style="font-size: 0.75em; padding: 6px 10px;">Open in Overseerr</button>` : ''}
                        </div>
                    </div>
                </div>`;
            });
            
            html += '</div>';
            
            // Add pagination controls
            if (data.pagination) {
                const pagination = data.pagination;
                html += '<div style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 10px; padding: 15px;">';
                
                // Previous button (only show if not on first page)
                if (pagination.page > 1) {
                    html += `<button class="action-btn" onclick="goToRequestedPage(${pagination.page - 1})" style="padding: 8px 16px;">‚Üê Previous</button>`;
                }
                
                // Page info (always show)
                html += `<span style="color: #888; padding: 0 15px;">Page ${pagination.page} of ${pagination.total_pages} (${pagination.total_items} total requests)</span>`;
                
                // Next button (only show if not on last page)
                if (pagination.page < pagination.total_pages) {
                    html += `<button class="action-btn" onclick="goToRequestedPage(${pagination.page + 1})" style="padding: 8px 16px;">Next ‚Üí</button>`;
                }
                
                html += '</div>';
            } else {
                // Fallback: show item count if pagination data not available
                html += `<div style="margin-top: 20px; text-align: center; color: #888; padding: 15px;">Showing ${data.items.length} requests</div>`;
            }
            
            container.innerHTML = html;
            
            // Store current page for pagination
            if (data.pagination) {
                const pageIndicator = document.getElementById('requested-page');
                if (pageIndicator) {
                    pageIndicator.textContent = data.pagination.page;
                } else {
                    // Create hidden element to store current page
                    const hiddenPage = document.createElement('span');
                    hiddenPage.id = 'requested-page';
                    hiddenPage.style.display = 'none';
                    hiddenPage.textContent = data.pagination.page;
                    container.appendChild(hiddenPage);
                }
            }
        })
        .catch(err => {
            container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading data: ${escapeHtml(String(err.message || ''))}</div>`;
        });
}

function goToRequestedPage(page) {
    const pageIndicator = document.getElementById('requested-page');
    if (!pageIndicator) {
        // Create hidden element if it doesn't exist
        const hiddenPage = document.createElement('span');
        hiddenPage.id = 'requested-page';
        hiddenPage.style.display = 'none';
        hiddenPage.textContent = page;
        document.getElementById('requested-table-container').appendChild(hiddenPage);
    } else {
        pageIndicator.textContent = page;
    }
    loadRequested();
}

function loadMovies() {
    console.log('loadMovies() called - fetching Radarr movies');
    const container = document.getElementById('movies-table-container');
    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading...</div>';
    
    const monitored = document.getElementById('filter-monitored-movies')?.value || '';
    const hasFile = document.getElementById('filter-has-file-movies')?.value || '';
    const sort = document.getElementById('sort-by-movies')?.value || 'added_desc';
    const pageSize = document.getElementById('page-size-movies')?.value || '200';
    
    // Get current page from hidden element or default to 1
    const pageElement = document.getElementById('movies-page');
    const page = pageElement ? parseInt(pageElement.textContent || '1') : 1;
    
    // Save page size preference to localStorage
    localStorage.setItem('pageSizeMovies', pageSize);
    
    const url = API_MEDIA_MOVIES + '?monitored=' + encodeURIComponent(monitored) + '&has_file=' + encodeURIComponent(hasFile) + '&sort=' + encodeURIComponent(sort) + '&page=' + page + '&page_size=' + pageSize;
    console.log('Fetching Radarr movies from:', url);
    
    fetch(url)
        .then(r => {
            console.log('Radarr response status:', r.status);
            return r.json();
        })
        .then(data => {
            // Debug: Log the response to console to see debug info
            console.log('Radarr API Response:', data);
            if (data.items && data.items.length > 0) {
                console.log('First movie debug info:', data.items[0]._debug);
                // Find "Evil Dead Burn" specifically
                const evilDead = data.items.find(m => m.title && m.title.toLowerCase().includes('evil dead') && m.title.toLowerCase().includes('burn'));
                if (evilDead) {
                    console.log('Evil Dead Burn debug info:', evilDead._debug);
                    console.log('Evil Dead Burn radarrUrl:', evilDead.radarrUrl);
                }
            }
            
            if (data.status === 'error') {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || ''))}</div>`;
                return;
            }
            
            if (data.items.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No movies found.</div>';
                return;
            }
            
            let html = '<div class="media-poster-grid">';
            
            data.items.forEach(item => {
                const posterUrl = item.poster_url || '';
                const statusBarClass = item.monitored ? 'monitored' : 'unmonitored';
                const fileBarClass = item.has_file ? 'has-file' : 'missing-file';
                const addedDate = item.added ? formatAddedDate(item.added) : 'N/A';
                
                html += `<div class="media-poster-card" onclick="showMovieDetail(${item.id})" style="cursor: pointer;">
                    <div class="media-poster-image-container">
                        ${posterUrl ? 
                            `<img src="${escapeHtml(posterUrl)}" alt="${escapeHtml(item.title)}" class="media-poster-image" onerror="this.parentElement.innerHTML='<div class=\\'media-poster-image-placeholder\\'>üé¨</div>'">` :
                            `<div class="media-poster-image-placeholder">üé¨</div>`
                        }
                    </div>
                    <div class="media-poster-info">
                        <div class="media-poster-title">${escapeHtml(item.title)}</div>
                        <div class="media-poster-status-bar ${statusBarClass}"></div>
                        <div class="media-poster-meta">
                            <div class="media-poster-meta-item">Monitored</div>
                            <div class="media-poster-meta-item">${item.quality || 'N/A'}</div>
                            <div class="media-poster-meta-item">Added: ${addedDate}</div>
                        </div>
                        <div class="media-poster-actions">
                            <button class="action-btn monitor-toggle-btn" onclick="event.stopPropagation(); toggleMonitored('radarr', ${item.id}, ${!item.monitored})" 
                                    style="font-size: 0.75em; padding: 6px 10px; ${item.monitored ? 'background: rgba(231, 76, 60, 0.2); border-color: #e74c3c;' : 'background: rgba(0, 204, 102, 0.2); border-color: #00CC66;'}">
                                ${item.monitored ? 'Unmonitor' : 'Monitor'}
                            </button>
                            <button class="action-btn" onclick="event.stopPropagation(); radarrAutoSearch(${item.id}, '${escapeJsString(item.title)}')" style="font-size: 0.75em; padding: 6px 10px; background: rgba(0, 204, 102, 0.2); border-color: #00CC66;">
                                üîç Search Movie
                            </button>
                            <button class="action-btn" onclick="event.stopPropagation(); radarrInteractiveSearch(${item.id}, '${escapeJsString(item.title)}')" style="font-size: 0.75em; padding: 6px 10px; background: rgba(52, 152, 219, 0.2); border-color: #3498db;">
                                üéØ Interactive Search
                            </button>
                            ${item.radarrUrl ? `<button class="action-btn" onclick="event.stopPropagation(); window.open('${escapeHtml(String(item.radarrUrl || ''))}', '_blank')" style="font-size: 0.75em; padding: 6px 10px;">Open in Radarr</button>` : ''}
                        </div>
                    </div>
                </div>`;
            });
            
            html += '</div>';
            
            // Add pagination controls
            if (data.pagination) {
                const pagination = data.pagination;
                html += '<div style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 10px; padding: 15px;">';
                
                // Previous button (only show if not on first page)
                if (pagination.page > 1) {
                    html += `<button class="action-btn" onclick="goToMoviesPage(${pagination.page - 1})" style="padding: 8px 16px;">‚Üê Previous</button>`;
                }
                
                // Page info (always show)
                html += `<span style="color: #888; padding: 0 15px;">Page ${pagination.page} of ${pagination.total_pages} (${pagination.total_items} total movies)</span>`;
                
                // Next button (only show if not on last page)
                if (pagination.page < pagination.total_pages) {
                    html += `<button class="action-btn" onclick="goToMoviesPage(${pagination.page + 1})" style="padding: 8px 16px;">Next ‚Üí</button>`;
                }
                
                html += '</div>';
            } else {
                // Fallback: show item count if pagination data not available
                html += `<div style="margin-top: 20px; text-align: center; color: #888; padding: 15px;">Showing ${data.items.length} movies</div>`;
            }
            
            container.innerHTML = html;
            
            // Update current movie IDs set for cache invalidation
            detailCache.currentMovieIds.clear();
            data.items.forEach(item => {
                detailCache.currentMovieIds.add(item.id);
            });
            
            // Invalidate cache for movies that no longer exist
            invalidateDeletedItems('movies');
            
            // Store current page for pagination
            if (data.pagination) {
                const pageIndicator = document.getElementById('movies-page');
                if (pageIndicator) {
                    pageIndicator.textContent = data.pagination.page;
                } else {
                    // Create hidden element to store current page
                    const hiddenPage = document.createElement('span');
                    hiddenPage.id = 'movies-page';
                    hiddenPage.style.display = 'none';
                    hiddenPage.textContent = data.pagination.page;
                    container.appendChild(hiddenPage);
                }
            }
        })
        .catch(err => {
            console.error('Error loading Radarr movies:', err);
            container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading data: ${escapeHtml(String(err.message || ''))}</div>`;
        });
}

function goToMoviesPage(page) {
    const pageIndicator = document.getElementById('movies-page');
    if (!pageIndicator) {
        // Create hidden element if it doesn't exist
        const hiddenPage = document.createElement('span');
        hiddenPage.id = 'movies-page';
        hiddenPage.style.display = 'none';
        hiddenPage.textContent = page;
        document.getElementById('movies-table-container').appendChild(hiddenPage);
    } else {
        pageIndicator.textContent = page;
    }
    loadMovies();
}

function loadTV() {
    const container = document.getElementById('tv-table-container');
    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading...</div>';
    
    const monitored = document.getElementById('filter-monitored-tv')?.value || '';
    const hasFile = document.getElementById('filter-has-file-tv')?.value || '';
    const sort = document.getElementById('sort-by-tv')?.value || 'added_desc';
    const pageSize = document.getElementById('page-size-tv')?.value || '200';
    
    // Get current page from hidden element or default to 1
    const pageElement = document.getElementById('tv-page');
    const page = pageElement ? parseInt(pageElement.textContent || '1') : 1;
    
    // Save page size preference to localStorage
    localStorage.setItem('pageSizeTV', pageSize);
    
    // Set up timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
    
    fetch(API_MEDIA_TV + '?monitored=' + encodeURIComponent(monitored) + '&has_file=' + encodeURIComponent(hasFile) + '&sort=' + encodeURIComponent(sort) + '&page=' + page + '&page_size=' + pageSize, {
        signal: controller.signal
    })
        .then(r => {
            clearTimeout(timeoutId);
            if (!r.ok) {
                throw new Error(`HTTP error! status: ${r.status}`);
            }
            return r.json();
        })
        .then(data => {
            clearTimeout(timeoutId);
            if (data.status === 'error') {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || ''))}</div>`;
                return;
            }
            
            if (data.items.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No TV shows found.</div>';
                return;
            }
            
            let html = '<div class="media-poster-grid">';
            
            data.items.forEach(item => {
                const posterUrl = item.poster_url || '';
                const statusBarClass = item.monitored ? 'monitored' : 'unmonitored';
                const addedDate = item.added ? formatAddedDate(item.added) : 'N/A';
                
                html += `<div class="media-poster-card" onclick="showSeriesDetail(${item.id})" style="cursor: pointer;">
                    <div class="media-poster-image-container">
                        ${posterUrl ? 
                            `<img src="${escapeHtml(posterUrl)}" alt="${escapeHtml(item.title)}" class="media-poster-image" onerror="this.parentElement.innerHTML='<div class=\\'media-poster-image-placeholder\\'>üì∫</div>'">` :
                            `<div class="media-poster-image-placeholder">üì∫</div>`
                        }
                    </div>
                    <div class="media-poster-info">
                        <div class="media-poster-title">${escapeHtml(item.title)}</div>
                        <div class="media-poster-status-bar ${statusBarClass}"></div>
                        <div class="media-poster-meta">
                            <div class="media-poster-meta-item">Monitored</div>
                            <div class="media-poster-meta-item">${item.quality || 'N/A'}</div>
                            <div class="media-poster-meta-item">Added: ${addedDate}</div>
                        </div>
                        <div class="media-poster-actions">
                            <button class="action-btn monitor-toggle-btn" onclick="event.stopPropagation(); toggleMonitored('sonarr', ${item.id}, ${!item.monitored})" 
                                    style="font-size: 0.75em; padding: 6px 10px; ${item.monitored ? 'background: rgba(231, 76, 60, 0.2); border-color: #e74c3c;' : 'background: rgba(0, 204, 102, 0.2); border-color: #00CC66;'}">
                                ${item.monitored ? 'Unmonitor' : 'Monitor'}
                            </button>
                            ${!item.has_file ? `<button class="action-btn" onclick="event.stopPropagation(); showMissingEpisodes(${item.id}, '${escapeJsString(item.title)}')" style="font-size: 0.75em; padding: 6px 10px; background: rgba(243, 156, 18, 0.2); border-color: #f39c12;">
                                üìã Missing Episodes
                            </button>` : ''}
                            ${!item.has_file ? `<button class="action-btn" onclick="event.stopPropagation(); sonarrAutoSearch(${item.id}, '${escapeJsString(item.title)}')" style="font-size: 0.75em; padding: 6px 10px; background: rgba(0, 204, 102, 0.2); border-color: #00CC66;">
                                üîç Search Monitored
                            </button>` : ''}
                            ${!item.has_file ? `<button class="action-btn" onclick="event.stopPropagation(); sonarrInteractiveSearch(${item.id}, '${escapeJsString(item.title)}')" style="font-size: 0.75em; padding: 6px 10px; background: rgba(52, 152, 219, 0.2); border-color: #3498db;">
                                üéØ Interactive Search
                            </button>` : ''}
                            ${item.sonarrUrl ? `<button class="action-btn" onclick="event.stopPropagation(); window.open('${escapeHtml(String(item.sonarrUrl || ''))}', '_blank')" style="font-size: 0.75em; padding: 6px 10px;">Open in Sonarr</button>` : ''}
                        </div>
                    </div>
                </div>`;
            });
            
            html += '</div>';
            
            // Add pagination controls
            if (data.pagination) {
                const pagination = data.pagination;
                html += '<div style="margin-top: 20px; display: flex; justify-content: center; align-items: center; gap: 10px; padding: 15px;">';
                
                // Previous button (only show if not on first page)
                if (pagination.page > 1) {
                    html += `<button class="action-btn" onclick="goToTVPage(${pagination.page - 1})" style="padding: 8px 16px;">‚Üê Previous</button>`;
                }
                
                // Page info (always show)
                html += `<span style="color: #888; padding: 0 15px;">Page ${pagination.page} of ${pagination.total_pages} (${pagination.total_items} total TV shows)</span>`;
                
                // Next button (only show if not on last page)
                if (pagination.page < pagination.total_pages) {
                    html += `<button class="action-btn" onclick="goToTVPage(${pagination.page + 1})" style="padding: 8px 16px;">Next ‚Üí</button>`;
                }
                
                html += '</div>';
            } else {
                // Fallback: show item count if pagination data not available
                html += `<div style="margin-top: 20px; text-align: center; color: #888; padding: 15px;">Showing ${data.items.length} TV shows</div>`;
            }
            
            container.innerHTML = html;
            
            // Update current series IDs set for cache invalidation
            detailCache.currentSeriesIds.clear();
            data.items.forEach(item => {
                detailCache.currentSeriesIds.add(item.id);
            });
            
            // Invalidate cache for series that no longer exist
            invalidateDeletedItems('series');
            
            // Store current page for pagination
            if (data.pagination) {
                const pageIndicator = document.getElementById('tv-page');
                if (pageIndicator) {
                    pageIndicator.textContent = data.pagination.page;
                } else {
                    // Create hidden element to store current page
                    const hiddenPage = document.createElement('span');
                    hiddenPage.id = 'tv-page';
                    hiddenPage.style.display = 'none';
                    hiddenPage.textContent = data.pagination.page;
                    container.appendChild(hiddenPage);
                }
            }
        })
        .catch(err => {
            clearTimeout(timeoutId);
            console.error('Error loading TV shows:', err);
            if (err.name === 'AbortError') {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Request timed out after 30 seconds. Please try again.</div>`;
            } else {
                container.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading data: ${escapeHtml(String(err.message || 'Unknown error'))}</div>`;
            }
        });
}

function goToTVPage(page) {
    const pageIndicator = document.getElementById('tv-page');
    if (!pageIndicator) {
        // Create hidden element if it doesn't exist
        const hiddenPage = document.createElement('span');
        hiddenPage.id = 'tv-page';
        hiddenPage.style.display = 'none';
        hiddenPage.textContent = page;
        document.getElementById('tv-table-container').appendChild(hiddenPage);
    } else {
        pageIndicator.textContent = page;
    }
    loadTV();
}

function toggleMonitored(service, id, monitored) {
    let url = '';
    if (service === 'radarr') {
        url = API_RADARR_TOGGLE_MONITORED_BASE.replace(/\/0$/, '/' + id);
    } else if (service === 'sonarr') {
        url = API_SONARR_TOGGLE_MONITORED_BASE.replace(/\/0$/, '/' + id);
    } else {
        alert('Unknown service');
        return;
    }
    
    fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'}
    })
    .then(r => r.json())
    .then(data => {
            if (data.status === 'success') {
                // Clear cache for this item
                if (service === 'radarr') {
                    delete detailCache.movies[id];
                } else if (service === 'sonarr') {
                    delete detailCache.series[id];
                }
                loadMediaData();
                // If detail modal is open, refresh it
                // Refresh detail view if open
                if (service === 'radarr') {
                    const detailContainer = document.getElementById('movies-detail-container');
                    if (detailContainer && detailContainer.style.display !== 'none') {
                        showMovieDetail(id, true); // Force refresh
                    }
                } else if (service === 'sonarr') {
                    const detailContainer = document.getElementById('tv-detail-container');
                    if (detailContainer && detailContainer.style.display !== 'none') {
                        showSeriesDetail(id, true); // Force refresh
                    }
                }
            } else {
                alert(data.message || 'Failed to update');
            }
    })
    .catch(err => alert('Error: ' + err.message));
}

function formatSize(bytes) {
    if (!bytes || bytes === 0 || bytes === null || bytes === undefined) return 'N/A';
    const gb = bytes / (1024 * 1024 * 1024);
    if (gb >= 1) return gb.toFixed(2) + ' GB';
    const mb = bytes / (1024 * 1024);
    return mb.toFixed(2) + ' MB';
}

function formatAddedDate(dateString) {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffDays === 0) {
            return 'Today';
        } else if (diffDays === 1) {
            return 'Yesterday';
        } else if (diffDays < 7) {
            return `${diffDays} days ago`;
        } else {
            // Format as "Jan DD YYYY"
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            return `${month} ${day} ${year}`;
        }
    } catch (e) {
        return 'N/A';
    }
}

function escapeHtml(text) {
    // Handle null/undefined
    if (text === null || text === undefined) return '';
    
    // Convert to string first - handle all edge cases
    let textStr;
    try {
        textStr = String(text);
    } catch (e) {
        return '';
    }
    
    // Double-check it's a string
    if (typeof textStr !== 'string') {
        try {
            textStr = String(textStr);
        } catch (e) {
            return '';
        }
        if (typeof textStr !== 'string') {
            return '';
        }
    }
    
    // Use DOM-based escaping (most reliable)
    try {
        const div = document.createElement('div');
        div.textContent = textStr;
        const result = div.innerHTML;
        // Ensure we always return a string
        if (result && typeof result === 'string') {
            return result;
        }
    } catch (e) {
        // Fall through to manual escaping
    }
    
    // Fallback to manual escaping if DOM manipulation fails or returns non-string
    try {
        // ensure we have a primitive string before calling replace
        let safeStr = textStr;
        
        // if it's not already a string primitive, convert it
        if (typeof safeStr !== 'string') {
            // try valueOf first if it exists (for String objects)
            if (safeStr && typeof safeStr.valueOf === 'function') {
                try {
                    safeStr = String(safeStr.valueOf());
                } catch (e) {
                    safeStr = String(safeStr || '');
                }
            } else {
                safeStr = String(safeStr || '');
            }
        }
        
        // final check - must be a primitive string
        if (typeof safeStr !== 'string') {
            return '';
        }
        
        return safeStr
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    } catch (e) {
        return '';
    }
}

// For embedding in single-quoted JS strings (e.g. onclick="foo('...')") so apostrophes don't break
function escapeJsString(s) {
    if (s == null || s === undefined) return '';
    const str = String(s);
    return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

// Radarr search functions
function radarrAutoSearch(movieId, title) {
    if (!confirm(`Start auto search for "${title}"?`)) return;
    
    fetch(API_RADARR_SEARCH, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({movie_id: movieId, type: 'auto'})
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            alert('Search started! Check Radarr for results.');
        } else {
            alert('Error: ' + (data.message || 'Failed to start search'));
        }
    })
    .catch(err => alert('Error: ' + err.message));
}

// Interactive Search = you pick a download (always in modal)
function radarrInteractiveSearch(movieId, title) {
    const safeTitle = title ? String(title) : 'Unknown';
    document.getElementById('searchModalTitle').textContent = `Search Results: ${safeTitle}`;
    document.getElementById('searchModalBody').innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading releases...</div>';
    document.getElementById('searchModal').style.display = 'block';

    fetch(API_RADARR_SEARCH, {
        method: 'POST',
        headers: {'Content-Type': 'application/json', 'X-CSRFToken': MEDIA_CSRF},
        body: JSON.stringify({movie_id: movieId, type: 'interactive'})
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success' && data.releases) {
            displayRadarrReleases(data.releases, movieId, safeTitle, null, data.current_file || null);
        } else {
            document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || 'No releases found'))}</div>`;
        }
    })
    .catch(err => {
        document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${escapeHtml(String(err.message || err))}</div>`;
    });
}

// Store releases and sort state for interactive search (targetEl = inline container or null for modal)
let currentReleases = [];
let currentMovieId = null;
let currentTitle = '';
let currentReleasesTargetEl = null; // when set, render into this element instead of modal
let currentFileInfo = null; // { releaseGroup, quality } for "downloaded" icon
let sortColumn = null;
let sortDirection = 'asc'; // 'asc' or 'desc'

function displayRadarrReleases(releases, movieId, title, targetEl, currentFile) {
    currentReleasesTargetEl = targetEl || null;
    currentFileInfo = currentFile || null;
    const dest = targetEl || document.getElementById('searchModalBody');
    if (!dest) return;

    if (!releases || releases.length === 0) {
        dest.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No releases found</div>';
        return;
    }

    // Store releases and context for sorting
    currentReleases = [...releases];
    currentMovieId = movieId;
    currentTitle = title;
    sortColumn = null;
    sortDirection = 'asc';

    if (releases.length > 0) {
        console.log('Sample Radarr release object:', releases[0]);
    }

    renderRadarrReleasesTable();
}

function renderRadarrReleasesTable() {
    const releases = currentReleases;
    const movieId = currentMovieId;
    const title = currentTitle;
    
    // Helper function to format age
    function formatAge(ageDays) {
        if (!ageDays && ageDays !== 0) return 'Unknown';
        if (ageDays < 1) return '<1 day';
        if (ageDays === 1) return '1 day';
        return `${Math.floor(ageDays)} days`;
    }
    
    // Helper function to get age in days
    function getAgeDays(release) {
        if (release.age) return release.age;
        if (release.ageHours) return release.ageHours / 24;
        if (release.ageMinutes) return release.ageMinutes / (24 * 60);
        if (release.publishDate) {
            const pubDate = new Date(release.publishDate);
            const now = new Date();
            const diffMs = now - pubDate;
            return Math.floor(diffMs / (1000 * 60 * 60 * 24));
        }
        return null;
    }
    
    // Helper function to get language
    function getLanguage(release) {
        if (release.languages && Array.isArray(release.languages) && release.languages.length > 0) {
            const lang = release.languages[0];
            if (lang && typeof lang === 'object' && lang.name) {
                return String(lang.name || 'Unknown');
            } else if (lang) {
                return String(lang);
            }
        }
        return 'Unknown';
    }
    
    // Helper function to get peer color class
    function getPeerClass(seeders, leechers) {
        const total = (seeders || 0) + (leechers || 0);
        if (total === 0) return 'peers-none';
        if (seeders < 5) return 'peers-low';
        return 'peers-good';
    }
    
    // Helper function to get sort indicator
    function getSortIndicator(col) {
        if (sortColumn !== col) return ' ‚Üï';
        return sortDirection === 'asc' ? ' ‚Üë' : ' ‚Üì';
    }
    
    // Helper function to create sortable header
    function createSortableHeader(col, label, align = 'left') {
        const isSorted = sortColumn === col;
        const indicator = getSortIndicator(col);
        const style = align === 'center' ? 'text-align: center;' : '';
        return `<th onclick="sortReleases('${col}')" style="${style} cursor: pointer; user-select: none; position: relative;" title="Click to sort by ${label}">
            ${label}${indicator}
        </th>`;
    }
    
    let html = '';
    if (currentReleasesTargetEl) {
        html += `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color); font-weight: 600;">Search results: ${escapeHtml(currentTitle)}</div>`;
    }
    html += '<div style="flex: 1; overflow-y: auto; overflow-x: auto; min-height: 0;">';
    html += '<table class="releases-table" style="min-width: 1200px;">';
    html += '<thead><tr>';
    html += createSortableHeader('source', 'Source');
    html += createSortableHeader('age', 'Age');
    html += createSortableHeader('title', 'Title');
    html += createSortableHeader('indexer', 'Indexer');
    html += createSortableHeader('size', 'Size');
    html += createSortableHeader('peers', 'Peers');
    html += createSortableHeader('language', 'Language');
    html += createSortableHeader('quality', 'Quality');
    html += createSortableHeader('customFormat', 'Custom Format', 'center');
    html += createSortableHeader('status', 'Status', 'center');
    html += '<th>Actions</th>'; // Actions column not sortable
    html += '</tr></thead><tbody>';
    
    releases.forEach((release, idx) => {
        const size = release.size ? formatSize(release.size) : 'Unknown';
        const ageDays = getAgeDays(release);
        const age = ageDays !== null ? formatAge(ageDays) : 'Unknown';
        
        // Handle quality - might be an object or string
        let quality = 'Unknown';
        if (release.quality) {
            if (typeof release.quality === 'string') {
                quality = release.quality;
            } else if (release.quality.quality && release.quality.quality.name) {
                quality = release.quality.quality.name;
            } else if (release.quality.name) {
                quality = release.quality.name;
            }
        }
        
        // Handle indexer - might be an object or string
        let indexer = 'Unknown';
        if (release.indexer) {
            if (typeof release.indexer === 'string') {
                indexer = release.indexer;
            } else if (release.indexer.name) {
                indexer = release.indexer.name;
            }
        }
        
        // Protocol (source)
        const protocol = (release.protocol || 'unknown').toLowerCase();
        const sourceBadge = protocol === 'torrent' ? 
            '<span class="source-badge torrent">torrent</span>' : 
            '<span class="source-badge usenet">usenet</span>';
        
        // Peers
        const seeders = release.seeders || 0;
        const leechers = release.leechers || 0;
        const peerClass = getPeerClass(seeders, leechers);
        const peers = `${seeders} / ${leechers}`;
        
        // Language
        const language = getLanguage(release);
        
        // Custom format score - show even if 0
        const customFormatScore = release.customFormatScore || 0;
        let customFormatDisplay = '';
        if (customFormatScore > 0) {
            customFormatDisplay = `<span class="custom-format-score">+${customFormatScore}</span>`;
        } else if (release.customFormats && Array.isArray(release.customFormats) && release.customFormats.length > 0) {
            // Show custom format names if score is 0 but formats exist
            const formatNames = release.customFormats.map(f => f.name || f).join(', ');
            customFormatDisplay = `<span class="custom-format-score zero" title="${escapeHtml(formatNames)}">0</span>`;
        } else {
            customFormatDisplay = `<span class="custom-format-score zero">0</span>`;
        }
        
        // Rejection status
        const rejected = release.rejected === true || release.temporarilyRejected === true;
        const rejectionIcon = rejected ? 
            '<span class="rejection-icon" title="' + escapeHtml((release.rejections || []).join('; ') || 'Rejected') + '">‚ö†</span>' : 
            '';
        // Already downloaded = only what Radarr reports (approved = this release is the one we have)
        const isDownloaded = release.approved === true;
        const downloadedIcon = isDownloaded ?
            '<span class="release-downloaded-icon" title="Already downloaded">‚úì</span>' : '';
        
        // Safely get guid and indexerId
        const guid = release.guid ? String(release.guid).replace(/'/g, "\\'") : '';
        const indexerId = release.indexerId || 0;
        const releaseTitle = release.title || 'Unknown';
        
        // Check if download is allowed (Radarr sets this)
        const downloadAllowed = release.downloadAllowed === true || release.downloadAllowed === "true";
        
        html += '<tr>';
        html += `<td>${sourceBadge}</td>`;
        html += `<td>${age}</td>`;
        html += `<td style="max-width: 300px; word-wrap: break-word;">${escapeHtml(releaseTitle)}</td>`;
        html += `<td>${escapeHtml(indexer)}</td>`;
        html += `<td>${size}</td>`;
        html += `<td class="${peerClass}">${peers}</td>`;
        html += `<td>${escapeHtml(language)}</td>`;
        html += `<td>${escapeHtml(quality)}</td>`;
        html += `<td style="text-align: center;">${customFormatDisplay}</td>`;
        html += `<td style="text-align: center;">${downloadedIcon || rejectionIcon || '-'}</td>`;
        html += '<td style="white-space: nowrap;">';
        // Always show both buttons - normal download if allowed, override if not allowed or rejected
        // Store release data in window object to avoid escaping issues in onclick
        // Sanitize release data to prevent XSS - only include safe fields
        const safeReleaseData = {
            guid: release.guid || '',
            indexerId: release.indexerId || 0,
            mappedMovieId: release.mappedMovieId || null,
            downloadUrl: release.downloadUrl || '',
            magnetUrl: release.magnetUrl || '',
            protocol: release.protocol || '',
            quality: release.quality || null,
            downloadClientId: release.downloadClientId || null,
            infoHash: release.infoHash || ''
        };
        const releaseDataVar = `releaseData_${movieId}_${idx}`;
        // Store release data as JSON string in data attribute (will be parsed when button is clicked)
        const releaseDataJson = JSON.stringify(safeReleaseData);
        // Safely escape the JSON string for HTML attribute
        const escapedReleaseData = (releaseDataJson && typeof releaseDataJson === 'string') 
            ? releaseDataJson.replace(/'/g, "&#39;") 
            : '';
        
        if (downloadAllowed) {
            // Add to download queue button (normal download)
            html += `<button class="action-btn radarr-download-btn" 
                    data-guid="${escapeHtml(guid)}" 
                    data-indexer-id="${indexerId}" 
                    data-movie-id="${movieId}" 
                    data-title="${escapeHtml(title)}" 
                    data-release-data='${escapedReleaseData}'
                    data-override="false"
                    title="Add to download queue"
                    style="background: rgba(0, 204, 102, 0.2); border-color: #00CC66; font-size: 0.8em; padding: 5px 10px; margin-right: 5px; cursor: pointer;">
                Add
            </button>`;
        }
        // Override and add to download queue button (force download even if rejected or not allowed)
        html += `<button class="action-btn radarr-download-btn" 
                data-guid="${escapeHtml(guid)}" 
                data-indexer-id="${indexerId}" 
                data-movie-id="${movieId}" 
                data-title="${escapeHtml(title)}" 
                data-release-data='${escapedReleaseData}'
                data-override="true"
                title="Override and add to download queue"
                style="background: rgba(255, 152, 0, 0.2); border-color: #ff9800; font-size: 0.8em; padding: 5px 10px; cursor: pointer;">
            Force
        </button>`;
        html += '</td>';
        
        // Debug: log first release's action buttons
        if (idx === 0) {
            console.log('First release actions - downloadAllowed:', downloadAllowed, 'customFormatScore:', customFormatScore);
        }
        html += '</tr>';
    });
    
    html += '</tbody></table></div>';
    const target = currentReleasesTargetEl || document.getElementById('searchModalBody');
    if (!target) return;
    target.style.display = 'flex';
    target.style.flexDirection = 'column';
    target.innerHTML = html;

    // Attach event listeners to download buttons
    target.querySelectorAll('.radarr-download-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const guid = this.getAttribute('data-guid');
            const indexerId = parseInt(this.getAttribute('data-indexer-id'));
            const movieId = parseInt(this.getAttribute('data-movie-id'));
            const title = this.getAttribute('data-title');
            const releaseDataJson = this.getAttribute('data-release-data');
            const override = this.getAttribute('data-override') === 'true';
            
            // Parse release data from JSON string
            let releaseData = null;
            if (releaseDataJson) {
                try {
                    releaseData = JSON.parse(releaseDataJson);
                } catch (e) {
                    console.error('Failed to parse release data:', e);
                }
            }
            
            downloadRadarrRelease(guid, indexerId, movieId, title, releaseData, override);
        });
    });
}

function sortReleases(column) {
    // Toggle direction if clicking same column, otherwise default to asc
    if (sortColumn === column) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
    } else {
        sortColumn = column;
        sortDirection = 'asc';
    }
    
    // Helper functions (same as in renderRadarrReleasesTable)
    function getAgeDays(release) {
        if (release.age) return release.age;
        if (release.ageHours) return release.ageHours / 24;
        if (release.ageMinutes) return release.ageMinutes / (24 * 60);
        if (release.publishDate) {
            const pubDate = new Date(release.publishDate);
            const now = new Date();
            const diffMs = now - pubDate;
            return Math.floor(diffMs / (1000 * 60 * 60 * 24));
        }
        return null;
    }
    
    function getLanguage(release) {
        if (release.languages && Array.isArray(release.languages) && release.languages.length > 0) {
            const lang = release.languages[0];
            if (lang && typeof lang === 'object' && lang.name) {
                return String(lang.name || 'Unknown');
            } else if (lang) {
                return String(lang);
            }
        }
        return 'Unknown';
    }
    
    function getQuality(release) {
        if (release.quality) {
            if (typeof release.quality === 'string') {
                return release.quality;
            } else if (release.quality.quality && release.quality.quality.name) {
                return release.quality.quality.name;
            } else if (release.quality.name) {
                return release.quality.name;
            }
        }
        return 'Unknown';
    }
    
    function getIndexer(release) {
        if (release.indexer) {
            if (typeof release.indexer === 'string') {
                return release.indexer;
            } else if (release.indexer.name) {
                return release.indexer.name;
            }
        }
        return 'Unknown';
    }
    
    function getPeers(release) {
        const seeders = release.seeders || 0;
        const leechers = release.leechers || 0;
        return seeders + leechers; // Total peers for sorting
    }
    
    // Sort the releases array
    currentReleases.sort((a, b) => {
        let aVal, bVal;
        
        switch (column) {
            case 'source':
                aVal = (a.protocol || 'unknown').toLowerCase();
                bVal = (b.protocol || 'unknown').toLowerCase();
                break;
            case 'age':
                aVal = getAgeDays(a);
                bVal = getAgeDays(b);
                // Handle null values - put them at the end
                if (aVal === null) aVal = Infinity;
                if (bVal === null) bVal = Infinity;
                break;
            case 'title':
                aVal = (a.title || '').toLowerCase();
                bVal = (b.title || '').toLowerCase();
                break;
            case 'indexer':
                aVal = getIndexer(a).toLowerCase();
                bVal = getIndexer(b).toLowerCase();
                break;
            case 'size':
                aVal = a.size || 0;
                bVal = b.size || 0;
                break;
            case 'peers':
                aVal = getPeers(a);
                bVal = getPeers(b);
                break;
            case 'language':
                aVal = getLanguage(a).toLowerCase();
                bVal = getLanguage(b).toLowerCase();
                break;
            case 'quality':
                aVal = getQuality(a).toLowerCase();
                bVal = getQuality(b).toLowerCase();
                break;
            case 'customFormat':
                aVal = a.customFormatScore || 0;
                bVal = b.customFormatScore || 0;
                break;
            case 'status':
                // Sort by rejection status (rejected = 1, not rejected = 0)
                aVal = (a.rejected === true || a.temporarilyRejected === true) ? 1 : 0;
                bVal = (b.rejected === true || b.temporarilyRejected === true) ? 1 : 0;
                break;
            default:
                return 0;
        }
        
        // Compare values
        let comparison = 0;
        if (aVal < bVal) {
            comparison = -1;
        } else if (aVal > bVal) {
            comparison = 1;
        }
        
        // Apply sort direction
        return sortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-render the table
    renderRadarrReleasesTable();
}

function downloadRadarrRelease(guid, indexerId, movieId, title, releaseDataJson, override) {
    // Handle override parameter - might be string "true"/"false" or boolean
    const isOverride = override === true || override === "true" || override === 1;
    const confirmMsg = isOverride ? 
        `Override restrictions and download "${title}"?` : 
        `Download "${title}"?`;
    if (!confirm(confirmMsg)) return;
    
    // Parse release data - Radarr's web UI sends the full release object
    let payload = {guid: guid, indexerId: indexerId, movieId: movieId};
    if (releaseDataJson) {
        try {
            let releaseData;
            // Handle both object and string inputs
            if (typeof releaseDataJson === 'object') {
                releaseData = releaseDataJson;
            } else if (releaseDataJson && typeof releaseDataJson === 'string') {
                // Unescape the JSON (reverse the escaping we did)
                const unescapedJson = releaseDataJson
                    .replace(/&quot;/g, '"')
                    .replace(/\\'/g, "'")
                    .replace(/\\\\/g, '\\');
                try {
                    releaseData = JSON.parse(unescapedJson);
                } catch (e) {
                    console.error('Failed to parse release data:', e);
                    releaseData = null;
                }
            } else {
                releaseData = null;
            }
            
            // Use mappedMovieId if available (Radarr sets this to match the release to the movie)
            // Otherwise fall back to the movieId we passed
            const finalMovieId = releaseData.mappedMovieId || movieId;
            
            // Send the full release object (like Radarr's web UI does)
            // Backend will use it directly
            payload = {
                guid: guid,
                indexerId: indexerId,
                movieId: finalMovieId,  // Use mappedMovieId if available
                releaseData: releaseData,  // Send full release object
                override: isOverride  // Override flag for forced downloads
            };
            console.log('Override mode:', isOverride);
            console.log('Sending full release object with', Object.keys(releaseData).length, 'fields');
            console.log('Release object keys:', Object.keys(releaseData));
            console.log('Using movieId:', finalMovieId, '(mappedMovieId:', releaseData.mappedMovieId, ', passed movieId:', movieId, ')');
        } catch (e) {
            console.error('Could not parse release data:', e);
            console.error('Release data JSON:', releaseDataJson.substring(0, 200));
            // Fallback to minimal payload if parsing fails
        }
    }
    
    fetch(API_RADARR_DOWNLOAD, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
    })
    .then(r => {
        // Log response for debugging
        console.log('Download response status:', r.status);
        return r.json().then(data => {
            console.log('Download response data:', data);
            return {status: r.status, data: data};
        });
    })
    .then(result => {
        const data = result.data;
        if (data.status === 'success') {
            alert('Download started!');
            // Re-fetch releases so "already downloaded" status updates (Radarr sets approved on the release we grabbed)
            if (currentMovieId != null && currentTitle) {
                fetch(API_RADARR_SEARCH, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'X-CSRFToken': MEDIA_CSRF},
                    body: JSON.stringify({ movie_id: currentMovieId, type: 'interactive' })
                }).then(r => r.json()).then(refresh => {
                    if (refresh.status === 'success' && refresh.releases) {
                        displayRadarrReleases(refresh.releases, currentMovieId, currentTitle, null, refresh.current_file || null);
                    }
                }).catch(() => {});
            } else {
                closeSearchModal();
            }
        } else {
            // Show more detailed error message
            const errorMsg = data.message || 'Failed to start download';
            console.error('Download failed:', errorMsg, 'Full response:', data);
            
            // If we have Radarr's response, show it for debugging
            let fullErrorMsg = errorMsg;
            if (data.radarr_response) {
                console.error('Radarr response:', data.radarr_response);
                // Try to extract more details from Radarr's response
                const radarrMsg = data.radarr_response.message || data.radarr_response.errorMessage || '';
                if (radarrMsg && radarrMsg !== errorMsg) {
                    fullErrorMsg = `${errorMsg}\n\nRadarr says: ${radarrMsg}`;
                }
            }
            
            // Show error in a more readable format (replace \n with actual line breaks)
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'white-space: pre-wrap; text-align: left; max-width: 500px;';
            errorDiv.textContent = 'Error: ' + fullErrorMsg;
            alert(errorDiv.textContent);
        }
    })
    .catch(err => {
        console.error('Download request failed:', err);
        alert('Error: ' + err.message);
    });
}

// Sonarr search functions
function sonarrAutoSearch(seriesId, title) {
    if (!confirm(`Start auto search for missing episodes of "${title}"?`)) return;
    
    fetch(API_SONARR_SEARCH, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({series_id: seriesId, type: 'auto'})
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            alert(data.message || 'Search started! Check Sonarr for results.');
        } else {
            alert('Error: ' + (data.message || 'Failed to start search'));
        }
    })
    .catch(err => alert('Error: ' + err.message));
}

// Interactive Search = you pick a download (always in modal). Optional seasonNumber when called from a season row.
function sonarrInteractiveSearch(seriesId, title, seasonNumber) {
    const subTitle = seasonNumber !== undefined && seasonNumber !== null ? `Season ${seasonNumber}` : '';
    document.getElementById('searchModalTitle').textContent = subTitle ? `Search Results: ${title}: ${subTitle}` : `Search Results: ${title}`;
    document.getElementById('searchModalBody').innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading releases...</div>';
    document.getElementById('searchModal').style.display = 'block';

    const body = { series_id: seriesId, type: 'interactive' };
    if (seasonNumber !== undefined && seasonNumber !== null) body.season_number = seasonNumber;

    fetch(API_SONARR_SEARCH, {
        method: 'POST',
        headers: {'Content-Type': 'application/json', 'X-CSRFToken': MEDIA_CSRF},
        body: JSON.stringify(body)
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success' && data.releases) {
            displaySonarrReleases(data.releases, data.episode, seriesId, title, null, data.current_file || null);
        } else {
            document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || 'No releases found'))}</div>`;
        }
    })
    .catch(err => {
        document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${escapeHtml(String(err.message || err))}</div>`;
    });
}

function displaySonarrReleases(releases, episode, seriesId, title, targetEl, currentFile) {
    const dest = targetEl || document.getElementById('searchModalBody');
    if (!dest) return;
    // store for re-fetch after grab (so status updates)
    if (!targetEl) {
        window._lastSonarrInteractiveSeriesId = seriesId;
        window._lastSonarrInteractiveTitle = title;
    }

    if (!releases || releases.length === 0) {
        dest.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No releases found</div>';
        return;
    }

    const epInfo = episode ? `S${String(episode.seasonNumber || 0).padStart(2, '0')}E${String(episode.episodeNumber || 0).padStart(2, '0')} - ${escapeHtml(episode.title || '')}` : '';
    let html = '';
    if (targetEl) {
        html += `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color); font-weight: 600;">Search results: ${escapeHtml(title || '')}</div>`;
    }
    html += `<div style="margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 4px;"><strong>Episode:</strong> ${epInfo}</div>`;
    html += '<div style="max-height: 60vh; overflow-y: auto;">';

    releases.forEach(release => {
        const size = release.size ? formatSize(release.size) : 'Unknown';
        
        // Handle quality - might be an object or string
        let quality = 'Unknown';
        if (release.quality) {
            if (typeof release.quality === 'string') {
                quality = release.quality;
            } else if (release.quality.quality && release.quality.quality.name) {
                quality = release.quality.quality.name;
            } else if (release.quality.name) {
                quality = release.quality.name;
            }
        }
        
        // Handle indexer - might be an object or string
        let indexer = 'Unknown';
        if (release.indexer) {
            if (typeof release.indexer === 'string') {
                indexer = release.indexer;
            } else if (release.indexer.name) {
                indexer = release.indexer.name;
            }
        }
        
        // Already downloaded = only what Sonarr reports (approved = this release is the one we have)
        const isDownloaded = release.approved === true;
        const downloadedBadge = isDownloaded ? '<span class="release-downloaded-icon" title="Already downloaded" style="margin-left: 8px;">‚úì Downloaded</span>' : '';
        
        // Safely get guid, indexerId, and episodeId
        const guid = release.guid ? String(release.guid).replace(/'/g, "\\'") : '';
        const indexerId = release.indexerId || 0;
        const episodeId = episode && episode.id ? episode.id : 0;
        const releaseTitle = release.title || 'Unknown';
        
        html += `
            <div class="release-item">
                <div class="release-header">
                    <div class="release-title">${escapeHtml(releaseTitle)}${downloadedBadge}</div>
                    <div class="release-size">${size}</div>
                </div>
                <div class="release-info">
                    <span>Quality: ${escapeHtml(quality)}</span>
                    <span>Indexer: ${escapeHtml(indexer)}</span>
                    ${release.seeders ? `<span>Seeders: ${release.seeders}</span>` : ''}
                </div>
                <div class="release-actions">
                    <button class="action-btn" onclick="downloadSonarrRelease('${guid}', ${indexerId}, ${episodeId}, '${(escapeHtml(title) || '').replace(/'/g, "\\'")}')" 
                            title="Add to download queue"
                            style="background: rgba(0, 204, 102, 0.2); border-color: #00CC66;">
                        Add
                    </button>
                </div>
            </div>
        `;
    });
    html += '</div>';
    dest.innerHTML = html;
}

function downloadSonarrRelease(guid, indexerId, episodeId, title) {
    if (!confirm(`Download release for "${title}"?`)) return;
    
    fetch(API_SONARR_DOWNLOAD, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({guid: guid, indexerId: indexerId, episodeId: episodeId})
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success') {
            alert('Download started!');
            // Re-fetch releases so "already downloaded" status updates (Sonarr sets approved on the release we grabbed)
            const seriesId = window._lastSonarrInteractiveSeriesId;
            const seriesTitle = window._lastSonarrInteractiveTitle;
            if (seriesId != null && seriesTitle) {
                fetch(API_SONARR_SEARCH, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ series_id: seriesId, episode_ids: [episodeId], type: 'interactive' })
                }).then(r => r.json()).then(refresh => {
                    if (refresh.status === 'success' && refresh.releases) {
                        displaySonarrReleases(refresh.releases, refresh.episode, seriesId, seriesTitle, null, refresh.current_file || null);
                    }
                }).catch(() => {});
            } else {
                closeSearchModal();
            }
        } else {
            alert('Error: ' + (data.message || 'Failed to start download'));
        }
    })
    .catch(err => alert('Error: ' + err.message));
}

function closeSearchModal() {
    document.getElementById('searchModal').style.display = 'none';
}

// Show missing episodes for a series
function showMissingEpisodes(seriesId, title) {
    document.getElementById('searchModalTitle').textContent = `Missing Episodes: ${title}`;
    document.getElementById('searchModalBody').innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading missing episodes...</div>';
    document.getElementById('searchModal').style.display = 'block';
    
    fetch(API_SONARR_MISSING_EPISODES + '?series_id=' + encodeURIComponent(seriesId))
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success' && data.episodes && data.episodes.length > 0) {
            let html = '<div style="max-height: 60vh; overflow-y: auto;">';
            html += '<div style="margin-bottom: 15px; padding: 10px; background: #1a1a1a; border-radius: 4px;">';
            html += `<strong>Total Missing Episodes:</strong> ${data.episodes.length}`;
            html += '</div>';
            
            data.episodes.forEach(ep => {
                const seasonEp = `S${String(ep.seasonNumber || 0).padStart(2, '0')}E${String(ep.episodeNumber || 0).padStart(2, '0')}`;
                html += `
                    <div class="release-item">
                        <div class="release-header">
                            <div class="release-title">${seasonEp} - ${escapeHtml(ep.title || 'Untitled')}</div>
                            ${ep.airDate ? `<div class="release-size">${ep.airDate}</div>` : ''}
                        </div>
                        <div class="release-actions">
                            <button class="action-btn" onclick="sonarrSearchEpisode(${seriesId}, ${ep.id}, '${escapeJsString(title)}', '${escapeJsString(seasonEp)}')" 
                                    style="background: rgba(52, 152, 219, 0.2); border-color: #3498db;">
                                Search
                            </button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            document.getElementById('searchModalBody').innerHTML = html;
        } else {
            document.getElementById('searchModalBody').innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">No missing episodes found</div>';
        }
    })
    .catch(err => {
        document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${err.message}</div>`;
    });
}

function sonarrSearchEpisode(seriesId, episodeId, title, episodeInfo) {
    document.getElementById('searchModalTitle').textContent = `Search Results: ${title} - ${episodeInfo}`;
    document.getElementById('searchModalBody').innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading releases...</div>';
    
    fetch(API_SONARR_SEARCH, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({series_id: seriesId, episode_ids: [episodeId], type: 'interactive'})
    })
    .then(r => r.json())
    .then(data => {
        if (data.status === 'success' && data.releases) {
            displaySonarrReleases(data.releases, data.episode, seriesId, title, null, data.current_file || null);
        } else {
            document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || 'No releases found'))}</div>`;
        }
    })
    .catch(err => {
        document.getElementById('searchModalBody').innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${err.message}</div>`;
    });
}

// Close modal when clicking outside
window.onclick = function(event) {
    const searchModal = document.getElementById('searchModal');
    if (event.target === searchModal) {
        closeSearchModal();
    }
    const episodeModal = document.getElementById('episodeDetailModal');
    if (episodeModal && event.target === episodeModal) {
        closeEpisodeDetailModal();
    }
}

// Client-side cache for detail pages
// TTL Strategy:
// - 30 seconds: Very fresh data, good for active browsing (more API calls)
// - 60 seconds: Balanced (recommended) - fresh enough, reduces API load
// - 120 seconds: Conservative - fewer API calls, but data may be slightly stale
// Note: Cache is also invalidated on actions (monitor toggle, refresh, etc.) and when items are deleted
const detailCache = {
    movies: {},
    series: {},
    // TTL: 30 seconds = very fresh, 60 seconds = balanced, 120 seconds = conservative
    TTL: 60 * 1000, // 60 seconds (1 minute) - optimal balance between freshness and API usage
    // Track which items exist in current list to detect deletions
    currentMovieIds: new Set(),
    currentSeriesIds: new Set()
};

function getCachedDetail(type, id) {
    const cache = detailCache[type];
    if (cache[id]) {
        const cached = cache[id];
        const age = Date.now() - cached.timestamp;
        if (age < detailCache.TTL) {
            return cached.data;
        } else {
            delete cache[id]; // Expired, remove from cache
        }
    }
    return null;
}

function setCachedDetail(type, id, data) {
    detailCache[type][id] = {
        data: data,
        timestamp: Date.now()
    };
}

// Invalidate cache for items that no longer exist in the current list
function invalidateDeletedItems(type) {
    const cache = detailCache[type];
    const currentIds = type === 'movies' ? detailCache.currentMovieIds : detailCache.currentSeriesIds;
    let invalidated = 0;
    
    // Remove cache entries for items not in current list
    for (const cachedId in cache) {
        if (!currentIds.has(parseInt(cachedId))) {
            delete cache[cachedId];
            invalidated++;
        }
    }
    
    if (invalidated > 0) {
        console.log(`Invalidated ${invalidated} cached ${type} item(s) that no longer exist`);
    }
}

// Clear cache for a specific item (used when actions are performed)
function clearCachedDetail(type, id) {
    if (detailCache[type][id]) {
        delete detailCache[type][id];
        console.log(`Cleared cache for ${type} ID ${id}`);
    }
}

// Clear all cache for a type (used when major changes occur)
function clearAllCache(type) {
    detailCache[type] = {};
    console.log(`Cleared all ${type} cache`);
}

// Store list HTML when navigating to detail view
let storedMoviesListHTML = '';
let storedTVListHTML = '';

function showMovieDetail(movieId, forceRefresh = false) {
    // Update browser history (unless we're handling a popstate event)
    if (!window._skipHistoryUpdate) {
        const newUrl = `${window.location.pathname}${window.location.search}#movie/${movieId}`;
        window.history.pushState({type: 'movie', id: movieId}, '', newUrl);
    }
    
    // Store current list HTML
    const listContainer = document.getElementById('movies-table-container');
    if (listContainer) {
        storedMoviesListHTML = listContainer.innerHTML;
        listContainer.style.display = 'none';
    }
    
    // Show detail container
    const detailContainer = document.getElementById('movies-detail-container');
    if (!detailContainer) return;
    
    detailContainer.style.display = 'block';
    detailContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading movie details...</div>';
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
    // Check cache first (unless forcing refresh)
    if (!forceRefresh) {
        const cached = getCachedDetail('movies', movieId);
        if (cached) {
            try {
                renderMovieDetail(cached, detailContainer, movieId);
            } catch (err) {
                console.error('Error rendering cached movie detail:', err);
                detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error rendering movie: ${escapeHtml(String(err.message || err))}</div>`;
            }
            return;
        }
    }
    
    fetch(API_RADARR_MOVIE_BASE.replace(/\/0$/, '/' + movieId))
        .then(r => {
            if (r.status === 404) {
                return {status: 'error', message: 'Movie not found - it may have been deleted from Radarr', deleted: true};
            }
            return r.json();
        })
        .then(data => {
            if (data.status === 'error') {
                if (data.deleted) {
                    // Movie was deleted - refresh the list and go back
                    detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <p>${escapeHtml(String(data.message || ''))}</p>
                        <p style="margin-top: 15px; color: #888;">Refreshing movie list...</p>
                    </div>`;
                    // Remove from cache and current IDs set
                    clearCachedDetail('movies', movieId);
                    detailCache.currentMovieIds.delete(movieId);
                    // Refresh the movie list
                    setTimeout(() => {
                        loadMediaData();
                        goBackToList('movies');
                    }, 1500);
                } else {
                    detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || ''))}</div>`;
                }
                return;
            }
            
            const movie = data.movie;
            // Cache the result
            setCachedDetail('movies', movieId, movie);
            try {
                renderMovieDetail(movie, detailContainer, movieId);
            } catch (err) {
                console.error('Error rendering movie detail:', err);
                console.error('Movie data:', movie);
                detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error rendering movie: ${escapeHtml(String(err.message || err))}<br><small style="color: #888;">Check console for details</small></div>`;
            }
        })
        .catch(err => {
            console.error('Error fetching movie detail:', err);
            detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${escapeHtml(String(err.message || err))}</div>`;
        });
}

function showSeriesDetail(seriesId, forceRefresh = false) {
    // Update browser history (unless we're handling a popstate event)
    if (!window._skipHistoryUpdate) {
        const newUrl = `${window.location.pathname}${window.location.search}#tv/${seriesId}`;
        window.history.pushState({type: 'tv', id: seriesId}, '', newUrl);
    }
    
    // Store current list HTML
    const listContainer = document.getElementById('tv-table-container');
    if (listContainer) {
        storedTVListHTML = listContainer.innerHTML;
        listContainer.style.display = 'none';
    }
    
    // Show detail container
    const detailContainer = document.getElementById('tv-detail-container');
    if (!detailContainer) return;
    
    detailContainer.style.display = 'block';
    detailContainer.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading series details...</div>';
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
    // Check cache first (unless forcing refresh)
    if (!forceRefresh) {
        const cached = getCachedDetail('series', seriesId);
        if (cached) {
            try {
                renderSeriesDetail(cached, detailContainer, seriesId);
            } catch (err) {
                console.error('Error rendering cached series detail:', err);
                detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error rendering series: ${escapeHtml(String(err.message || err))}</div>`;
            }
            return;
        }
    }
    
    fetch(API_SONARR_SERIES_BASE.replace(/\/0$/, '/' + seriesId))
        .then(r => {
            if (r.status === 404) {
                return {status: 'error', message: 'Series not found - it may have been deleted from Sonarr', deleted: true};
            }
            return r.json();
        })
        .then(data => {
            if (data.status === 'error') {
                if (data.deleted) {
                    // Series was deleted - refresh the list and go back
                    detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">
                        <p>${escapeHtml(String(data.message || ''))}</p>
                        <p style="margin-top: 15px; color: #888;">Refreshing TV show list...</p>
                    </div>`;
                    // Remove from cache and current IDs set
                    clearCachedDetail('series', seriesId);
                    detailCache.currentSeriesIds.delete(seriesId);
                    // Refresh the TV show list
                    setTimeout(() => {
                        loadMediaData();
                        goBackToList('tv');
                    }, 1500);
                } else {
                    detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">${escapeHtml(String(data.message || ''))}</div>`;
                }
                return;
            }
            
            const series = data.series;
            // Cache the result
            setCachedDetail('series', seriesId, series);
            try {
                renderSeriesDetail(series, detailContainer, seriesId);
            } catch (err) {
                console.error('Error rendering series detail:', err);
                detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error rendering series: ${escapeHtml(String(err.message || err))}</div>`;
            }
        })
        .catch(err => {
            console.error('Error fetching series detail:', err);
            detailContainer.innerHTML = `<div style="text-align: center; padding: 40px; color: #e74c3c;">Error: ${escapeHtml(String(err.message || err))}</div>`;
        });
}

function goBackToList(type) {
    // Update browser history to remove hash (unless we're handling a popstate event)
    if (!window._skipHistoryUpdate) {
        const newUrl = `${window.location.pathname}${window.location.search}`;
        window.history.pushState({type: 'list', tab: type}, '', newUrl);
    }
    
    // Hide detail container and clear current detail id so search uses modal from list view
    const detailContainer = type === 'movies' ? document.getElementById('movies-detail-container') : document.getElementById('tv-detail-container');
    if (detailContainer) {
        detailContainer.style.display = 'none';
    }
    if (type === 'movies') window._currentDetailMovieId = null;
    if (type === 'tv') window._currentDetailSeriesId = null;
    
    // Show list container
    const listContainer = type === 'movies' ? document.getElementById('movies-table-container') : document.getElementById('tv-table-container');
    if (listContainer) {
        listContainer.style.display = 'block';
        // Restore stored HTML if available and not the Loading placeholder
        const storedHTML = type === 'movies' ? storedMoviesListHTML : storedTVListHTML;
        if (storedHTML && storedHTML.trim().length > 0 && storedHTML.indexOf('Loading...') === -1) {
            listContainer.innerHTML = storedHTML;
        } else {
            // No stored HTML, empty, or was Loading - reload the list
            if (type === 'movies') {
                loadMovies();
            } else if (type === 'tv') {
                loadTV();
            }
        }
    }
    
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Handle browser back/forward buttons
window.addEventListener('popstate', function(event) {
    // Check current URL hash
    const hash = window.location.hash;
    
    if (hash.startsWith('#movie/')) {
        const movieId = parseInt(hash.replace('#movie/', ''));
        if (movieId && !isNaN(movieId)) {
            // Show movie detail - switch to movies tab first
            switchMediaTab(null, 'movies');
            // Use a flag to prevent adding to history
            window._skipHistoryUpdate = true;
            showMovieDetail(movieId, false);
            delete window._skipHistoryUpdate;
            return;
        }
    } else if (hash.startsWith('#tv/')) {
        const seriesId = parseInt(hash.replace('#tv/', ''));
        if (seriesId && !isNaN(seriesId)) {
            // Show series detail - switch to TV tab first
            switchMediaTab(null, 'tv');
            // Use a flag to prevent adding to history
            window._skipHistoryUpdate = true;
            showSeriesDetail(seriesId, false);
            delete window._skipHistoryUpdate;
            return;
        }
    }
    
    // No hash or invalid hash - show list view
    const moviesDetail = document.getElementById('movies-detail-container');
    const tvDetail = document.getElementById('tv-detail-container');
    const moviesList = document.getElementById('movies-table-container');
    const tvList = document.getElementById('tv-table-container');
    
    if (moviesDetail && moviesDetail.style.display !== 'none') {
        moviesDetail.style.display = 'none';
        if (moviesList) {
            moviesList.style.display = 'block';
            if (storedMoviesListHTML && storedMoviesListHTML.indexOf('Loading...') === -1) {
                moviesList.innerHTML = storedMoviesListHTML;
            } else {
                // Stored HTML was Loading placeholder or missing - reload the list
                loadMovies();
            }
        }
    }
    if (tvDetail && tvDetail.style.display !== 'none') {
        tvDetail.style.display = 'none';
        if (tvList) {
            tvList.style.display = 'block';
            if (storedTVListHTML && storedTVListHTML.indexOf('Loading...') === -1) {
                tvList.innerHTML = storedTVListHTML;
            } else {
                loadTV();
            }
        }
    }
});

// Check URL hash on page load (for detail views and tab navigation)
document.addEventListener('DOMContentLoaded', function() {
    const hash = window.location.hash;
    
    if (hash.startsWith('#movie/')) {
        const movieId = parseInt(hash.replace('#movie/', ''));
        if (movieId && !isNaN(movieId)) {
            // Replace state to avoid double entry
            window.history.replaceState({type: 'movie', id: movieId}, '', window.location.href);
            // Switch to movies tab first
            switchMediaTab(null, 'movies');
            // Then show detail after a short delay to ensure tab is switched
            setTimeout(() => {
                showMovieDetail(movieId, false);
            }, 100);
        }
    } else if (hash.startsWith('#tv/')) {
        const seriesId = parseInt(hash.replace('#tv/', ''));
        if (seriesId && !isNaN(seriesId)) {
            // Replace state to avoid double entry
            window.history.replaceState({type: 'tv', id: seriesId}, '', window.location.href);
            // Switch to TV tab first
            switchMediaTab(null, 'tv');
            // Then show detail after a short delay to ensure tab is switched
            setTimeout(() => {
                showSeriesDetail(seriesId, false);
            }, 100);
        }
    } else if (hash === '#requested' || hash === '#radarr' || hash === '#sonarr') {
        // Tab navigation from sidebar
        const tabMap = {
            '#requested': 'requested',
            '#radarr': 'movies',
            '#sonarr': 'tv'
        };
        const tabName = tabMap[hash];
        if (tabName) {
            setTimeout(() => {
                switchMediaTab(null, tabName);
            }, 100);
        }
    } else {
        // No hash - default to requested tab
        switchMediaTab(null, 'requested');
        window.history.replaceState({type: 'tab', tab: 'requested'}, '', window.location.pathname + window.location.search + '#requested');
    }
});

// Keep closeDetailModal for backward compatibility but make it go back
function closeDetailModal() {
    // Try to determine which type we're in
    const moviesDetail = document.getElementById('movies-detail-container');
    const tvDetail = document.getElementById('tv-detail-container');
    
    if (moviesDetail && moviesDetail.style.display !== 'none') {
        goBackToList('movies');
    } else if (tvDetail && tvDetail.style.display !== 'none') {
        goBackToList('tv');
    }
}

function renderMovieDetail(movie, container, movieId) {
    window._currentDetailMovieId = movieId;
    // Safely extract and format runtime
    let runtime = '';
    if (movie.runtime && typeof movie.runtime === 'number') {
        const hours = Math.floor(movie.runtime / 60);
        const minutes = movie.runtime % 60;
        runtime = `${hours}h ${minutes}m`;
    }
    
    // Safely extract and format genres
    let genres = '';
    if (movie.genres && Array.isArray(movie.genres) && movie.genres.length > 0) {
        try {
            genres = movie.genres.map(g => {
                if (typeof g === 'string') return g;
                if (g && typeof g === 'object' && g.name) return String(g.name);
                return String(g || '');
            }).filter(g => g).join(', ');
        } catch (e) {
            genres = '';
        }
    }
    genres = String(genres || '');
    
    const cacheAge = movie._fetchedAt ? Math.floor((Date.now() / 1000 - movie._fetchedAt) / 60) : null;
    const cacheInfo = cacheAge !== null ? `<span style="color: #666; font-size: 0.85em; margin-left: 10px;">(Cached ${cacheAge} min ago)</span>` : '';
    
    let html = `
        <!-- Back Button -->
        <div style="margin-bottom: 20px;">
            <button class="action-btn" onclick="goBackToList('movies')" style="padding: 8px 16px; font-size: 0.9em; display: flex; align-items: center; gap: 8px;">
                ‚Üê Back to Radarr
            </button>
        </div>
        
        <!-- Action Buttons -->
        <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; align-items: center;">
            <button class="action-btn" onclick="radarrRefreshScan(${movie.id})" style="padding: 8px 16px;">
                üîÑ Refresh & Scan
            </button>
            <button class="action-btn" onclick="radarrSearchScan(${movie.id})" style="padding: 8px 16px;">
                üîç Search Movie
            </button>
            <button class="action-btn" onclick="radarrInteractiveSearch(${movie.id}, '${escapeJsString(movie.title || '')}');" style="padding: 8px 16px;">
                üéØ Interactive Search
            </button>
            <button class="action-btn" onclick="toggleMonitored('radarr', ${movie.id}, ${!movie.monitored})" style="padding: 8px 16px;">
                ${movie.monitored ? '‚è∏Ô∏è Unmonitor' : '‚ñ∂Ô∏è Monitor'}
            </button>
            <button class="action-btn" onclick="showMovieDetail(${movieId}, true)" style="padding: 8px 16px;" title="Force refresh from API">
                üîÉ Reload
            </button>
            ${movie.radarrUrl ? `<button class="action-btn" onclick="window.open('${escapeHtml(String(movie.radarrUrl || ''))}', '_blank')" style="padding: 8px 16px;">üîó Open in Radarr</button>` : ''}
            ${cacheInfo}
        </div>
        
        <!-- Live search results (Search Movie) - above poster -->
        <div id="movies-detail-search-results" class="media-detail-search-results" style="display: none; margin-bottom: 24px;"></div>
        
        <!-- Movie Header -->
        <div style="display: flex; gap: 20px; margin-bottom: 30px; flex-wrap: wrap;">
            <div style="flex-shrink: 0;">
                ${movie.posterUrl ? 
                    `<img src="${escapeHtml(String(movie.posterUrl || ''))}" alt="${escapeHtml(String(movie.title || ''))}" style="width: 200px; border-radius: 8px;">` :
                    `<div style="width: 200px; height: 300px; background: #1a1a1a; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 4em;">üé¨</div>`
                }
            </div>
            <div style="flex: 1; min-width: 300px;">
                <h1 style="margin: 0 0 10px 0; color: #fff; font-size: 2em;">${escapeHtml(String(movie.title || ''))} ${movie.year ? `(${escapeHtml(String(movie.year || ''))})` : ''}</h1>
                ${movie.certification ? `<span style="display: inline-block; padding: 4px 8px; background: #333; border-radius: 4px; margin-right: 10px; margin-bottom: 10px;">${escapeHtml(String(movie.certification || ''))}</span>` : ''}
                ${runtime ? `<span style="color: #aaa; margin-right: 10px;">${escapeHtml(runtime)}</span>` : ''}
                ${genres ? `<span style="color: #aaa;">${escapeHtml(String(genres || ''))}</span>` : ''}
                ${movie.studio ? `<div style="margin-top: 10px; color: #aaa;">Studio: ${escapeHtml(String(movie.studio || ''))}</div>` : ''}
                
                ${movie.ratings && (movie.ratings.tmdb || movie.ratings.imdb) ? `
                    <div style="margin-top: 15px; display: flex; gap: 15px; flex-wrap: wrap;">
                        ${movie.ratings.tmdb ? `<span style="color: var(--accent-color);">TMDB ${(movie.ratings.tmdb || 0).toFixed(1)}%</span>` : ''}
                        ${movie.ratings.imdb ? `<span style="color: #f39c12;">IMDb ${(movie.ratings.imdb || 0).toFixed(1)}</span>` : ''}
                    </div>
                ` : ''}
                
                ${movie.overview ? `
                    <div style="margin-top: 20px;">
                        <h3 style="color: var(--accent-color); margin-bottom: 10px;">Overview</h3>
                        <p style="color: #aaa; line-height: 1.6;">${escapeHtml(String(movie.overview || ''))}</p>
                    </div>
                ` : ''}
            </div>
        </div>
    `;
    
    // Status Section - show queue status if movie is downloading/paused
    if (movie.queueStatus) {
        let statusText = '';
        let statusColor = '';
        let statusIcon = '';
        
        if (movie.queueStatus === 'paused') {
            statusText = 'Paused';
            statusColor = '#f39c12'; // orange
            statusIcon = '‚è∏Ô∏è';
        } else if (movie.queueStatus === 'downloading') {
            statusText = 'Downloading';
            statusColor = '#3498db'; // blue
            statusIcon = '‚¨áÔ∏è';
        } else if (movie.queueStatus === 'queued') {
            statusText = 'Queued';
            statusColor = '#9b59b6'; // purple
            statusIcon = 'üì•';
        }
        
        if (statusText) {
            let progressText = '';
            if (movie.queueSize && movie.queueSizeLeft !== undefined) {
                const downloaded = movie.queueSize - movie.queueSizeLeft;
                const percent = Math.round((downloaded / movie.queueSize) * 100);
                progressText = ` (${percent}%)`;
            }
            
            html += `
                <div style="margin-top: 30px; background: #1a1a1a; padding: 20px; border-radius: 8px; border-left: 4px solid ${statusColor};">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5em;">${statusIcon}</span>
                        <div>
                            <h3 style="color: ${statusColor}; margin: 0 0 5px 0; font-size: 1.1em;">${statusText}${progressText}</h3>
                            ${movie.queueTitle ? `<p style="color: #aaa; margin: 0; font-size: 0.9em;">${escapeHtml(String(movie.queueTitle || ''))}</p>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
    }
    
    // Formats Section - show custom formats and score from files and movie level
    let allCustomFormats = new Set();
    let totalCustomFormatScore = 0; // use the score from file or movie level
    let hasAnyFile = false;
    
    // check movie-level formats first (some radarr versions store them here)
    if (movie.customFormats && Array.isArray(movie.customFormats)) {
        movie.customFormats.forEach(f => {
            let formatName = '';
            if (typeof f === 'string') {
                formatName = f.trim();
            } else if (f && typeof f === 'object') {
                const name = f.name || f.label || f.title || '';
                formatName = name ? String(name).trim() : '';
            }
            if (formatName && typeof formatName === 'string') {
                // ensure it's a string before adding to Set
                allCustomFormats.add(formatName.trim());
            }
        });
    }
    if (movie.customFormatScore !== undefined && movie.customFormatScore !== null) {
        totalCustomFormatScore = parseInt(movie.customFormatScore) || 0;
    }
    
    // also check files
    if (movie.files && movie.files.length > 0) {
        hasAnyFile = true;
        movie.files.forEach(file => {
            // debug logging
            console.log('File custom formats:', file.customFormats);
            console.log('File custom format score:', file.customFormatScore);
            
            // extract custom formats - handle both string and object formats
            if (file.customFormats && Array.isArray(file.customFormats)) {
                file.customFormats.forEach(f => {
                    let formatName = '';
                    if (typeof f === 'string') {
                        formatName = f.trim();
                    } else if (f && typeof f === 'object') {
                        // try different possible field names
                        const name = f.name || f.label || f.title || '';
                        formatName = name ? String(name).trim() : '';
                    }
                    if (formatName && typeof formatName === 'string') {
                        // ensure it's a string before adding to Set
                        allCustomFormats.add(formatName.trim());
                    }
                });
            }
            // use file score if it's higher (each file has its own total score)
            if (file.customFormatScore !== undefined && file.customFormatScore !== null) {
                const score = parseInt(file.customFormatScore) || 0;
                if (score > totalCustomFormatScore) {
                    totalCustomFormatScore = score;
                }
            }
        });
    }
    
    console.log('Movie-level custom formats:', movie.customFormats);
    console.log('Movie-level custom format score:', movie.customFormatScore);
    console.log('All custom formats found:', Array.from(allCustomFormats));
    console.log('Total custom format score:', totalCustomFormatScore);
    
    // always show formats section if there are files
    if (hasAnyFile) {
        html += `
            <div style="margin-top: 30px; background: #1a1a1a; padding: 20px; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="color: var(--accent-color); margin: 0;">Formats</h2>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
        `;
        
        // show format tags
        if (allCustomFormats.size > 0) {
            Array.from(allCustomFormats).forEach(formatName => {
                // ensure formatName is a string - extra defensive checks
                let formatStr = '';
                try {
                    if (formatName === null || formatName === undefined) {
                        return; // skip null/undefined
                    }
                    if (typeof formatName === 'string') {
                        formatStr = formatName.trim();
                    } else if (typeof formatName === 'object' && formatName !== null) {
                        // if it's an object, try to extract a string value
                        let name = formatName.name || formatName.label || formatName.title || '';
                        // if still no name, try calling toString (but safely)
                        if (!name && typeof formatName.toString === 'function') {
                            try {
                                name = formatName.toString();
                            } catch (e) {
                                // ignore toString errors
                            }
                        }
                        formatStr = name ? String(name).trim() : '';
                    } else {
                        formatStr = String(formatName || '').trim();
                    }
                    // final check - must be a non-empty string
                    if (formatStr && typeof formatStr === 'string') {
                        html += `<span style="display: inline-block; padding: 6px 12px; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 6px; color: #3498db; font-size: 0.9em; font-weight: 500;">${escapeHtml(formatStr)}</span>`;
                    }
                } catch (e) {
                    console.warn('Error processing format name:', formatName, e);
                    // skip this format if there's any error
                }
            });
        }
        
        // show score (always show if present, even if 0)
        if (totalCustomFormatScore !== undefined && totalCustomFormatScore !== null) {
            const score = parseInt(totalCustomFormatScore) || 0;
            if (score > 0) {
                html += `<span style="color: var(--accent-color); font-weight: 600; font-size: 1.1em; margin-left: ${allCustomFormats.size > 0 ? '10px' : '0'};">+${score}</span>`;
            } else {
                html += `<span style="color: #888; font-size: 0.9em; margin-left: ${allCustomFormats.size > 0 ? '10px' : '0'};">0</span>`;
            }
        }
        
        // if we have neither formats nor score, show message
        if (allCustomFormats.size === 0 && (totalCustomFormatScore === undefined || totalCustomFormatScore === null || totalCustomFormatScore === 0)) {
            html += `<span style="color: #888; font-size: 0.9em;">No custom formats matched</span>`;
        }
        
        html += `
                </div>
            </div>
        `;
    }
    
    // Files Section
    if (movie.files && movie.files.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Files</h2>
                <table class="media-table" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Path</th>
                            <th>Quality</th>
                            <th>Size</th>
                            <th>Video Codec</th>
                            <th>Audio Info</th>
                            <th>Languages</th>
                            <th>Release Group</th>
                            <th>Formats</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        movie.files.forEach(file => {
            // Format audio info (codec + channels)
            let audioInfo = 'N/A';
            if (file.mediaInfo) {
                const codec = String(file.mediaInfo.audioCodec || '');
                const channels = String(file.mediaInfo.audioChannels || '');
                if (codec || channels) {
                    audioInfo = `${escapeHtml(codec)}${channels ? '-' + escapeHtml(channels) : ''}`;
                }
            }
            
            // Format custom formats as tags
            let formatsHtml = 'N/A';
            if (file.customFormats && Array.isArray(file.customFormats) && file.customFormats.length > 0) {
                formatsHtml = file.customFormats.map(f => {
                    // handle both string and object formats
                    let formatName = '';
                    if (typeof f === 'string') {
                        formatName = f.trim();
                    } else if (f && typeof f === 'object') {
                        const name = f.name || f.label || f.title || '';
                        formatName = name ? String(name).trim() : '';
                    }
                    return formatName && typeof formatName === 'string' ? `<span style="display: inline-block; padding: 2px 6px; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 4px; margin: 2px; font-size: 0.85em; color: #3498db;">${escapeHtml(formatName)}</span>` : '';
                }).filter(f => f).join('');
                // Add score if available (show even if 0, but highlight if > 0)
                if (file.customFormatScore !== undefined && file.customFormatScore !== null) {
                    const score = parseInt(file.customFormatScore) || 0;
                    if (score > 0) {
                        formatsHtml += ` <span style="color: var(--accent-color); font-weight: 600; margin-left: 5px;">+${score}</span>`;
                    } else if (formatsHtml && formatsHtml !== 'N/A') {
                        formatsHtml += ` <span style="color: #888; font-size: 0.85em; margin-left: 5px;">(0)</span>`;
                    }
                }
                // If we have formats but no HTML was generated, show a message
                if (!formatsHtml || formatsHtml === '') {
                    formatsHtml = '<span style="color: #888; font-size: 0.85em;">No format names available</span>';
                }
            } else if (file.customFormatScore !== undefined && file.customFormatScore !== null) {
                // Show score even if no format names
                const score = parseInt(file.customFormatScore) || 0;
                formatsHtml = `<span style="color: ${score > 0 ? 'var(--accent-color)' : '#888'}; font-weight: 600;">${score > 0 ? '+' : ''}${score}</span>`;
            }
            
            html += `
                <tr>
                    <td style="max-width: 300px; word-wrap: break-word;">${escapeHtml(String(file.path || ''))}</td>
                    <td>${escapeHtml(String(file.quality || ''))}</td>
                    <td>${file.size ? formatSize(file.size) : 'N/A'}</td>
                    <td>${file.mediaInfo ? escapeHtml(String(file.mediaInfo.videoCodec || '')) : 'N/A'}</td>
                    <td>${audioInfo}</td>
                    <td>${file.languages && file.languages.length > 0 ? file.languages.map(l => {
                        const langStr = String(l || '');
                        return `<span style="display: inline-block; padding: 2px 6px; background: rgba(149, 165, 166, 0.2); border: 1px solid #95a5a6; border-radius: 4px; margin: 2px; font-size: 0.85em;">${escapeHtml(langStr)}</span>`;
                    }).join('') : 'N/A'}</td>
                    <td>${file.releaseGroup ? escapeHtml(String(file.releaseGroup || '')) : 'N/A'}</td>
                    <td>${formatsHtml}</td>
                </tr>
            `;
        });
        html += `
                    </tbody>
                </table>
            </div>
        `;
    }
    
    // Cast Section
    if (movie.cast && movie.cast.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Cast</h2>
                <div style="display: flex; gap: 15px; overflow-x: auto; padding-bottom: 10px;">
        `;
        movie.cast.forEach(person => {
            const personName = String(person.name || '');
            const personChar = String(person.character || '');
            const profilePath = String(person.profile_path || '');
            html += `
                <div style="min-width: 120px; text-align: center;">
                    ${profilePath ? 
                        `<img src="https://image.tmdb.org/t/p/w185${escapeHtml(profilePath)}" alt="${escapeHtml(personName)}" style="width: 120px; height: 180px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;">` :
                        `<div style="width: 120px; height: 180px; background: #1a1a1a; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; font-size: 2em;">üë§</div>`
                    }
                    <div style="color: #fff; font-weight: 600; margin-bottom: 4px;">${escapeHtml(personName)}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${escapeHtml(personChar)}</div>
                </div>
            `;
        });
        html += `
                </div>
            </div>
        `;
    }
    
    // Crew Section
    if (movie.crew && movie.crew.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Crew</h2>
                <div style="display: flex; gap: 15px; overflow-x: auto; padding-bottom: 10px;">
        `;
        movie.crew.forEach(person => {
            const personName = String(person.name || '');
            const personJob = String(person.job || '');
            const profilePath = String(person.profile_path || '');
            html += `
                <div style="min-width: 120px; text-align: center;">
                    ${profilePath ? 
                        `<img src="https://image.tmdb.org/t/p/w185${escapeHtml(profilePath)}" alt="${escapeHtml(personName)}" style="width: 120px; height: 180px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;">` :
                        `<div style="width: 120px; height: 180px; background: #1a1a1a; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; font-size: 2em;">üë§</div>`
                    }
                    <div style="color: #fff; font-weight: 600; margin-bottom: 4px;">${escapeHtml(personName)}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${escapeHtml(personJob)}</div>
                </div>
            `;
        });
        html += `
                </div>
            </div>
        `;
    }
    
    // Alternative Titles
    if (movie.alternativeTitles && movie.alternativeTitles.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Alternative Titles</h2>
                <table class="media-table" style="width: 100%;">
                    <thead>
                        <tr>
                            <th>Title</th>
                            <th>Source</th>
                        </tr>
                    </thead>
                    <tbody>
        `;
        movie.alternativeTitles.forEach(alt => {
            const altTitle = String(alt.title || '');
            const altSource = String(alt.sourceType || '');
            html += `
                <tr>
                    <td>${escapeHtml(altTitle)}</td>
                    <td>${escapeHtml(altSource)}</td>
                </tr>
            `;
        });
        html += `
                    </tbody>
                </table>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

function renderSeriesDetail(series, container, seriesId) {
    window._currentDetailSeriesId = seriesId;
    // keep reference so episode row click can open detail modal
    window._currentSonarrSeries = series;

    // Safely extract and format genres
    let genres = '';
    if (series.genres && Array.isArray(series.genres) && series.genres.length > 0) {
        try {
            genres = series.genres.map(g => {
                if (typeof g === 'string') return g;
                if (g && typeof g === 'object' && g.name) return String(g.name);
                return String(g || '');
            }).filter(g => g).join(', ');
        } catch (e) {
            genres = '';
        }
    }
    genres = String(genres || '');
    
    // Calculate total size and episode counts
    let totalSize = 0;
    let totalEpisodes = 0;
    let collectedEpisodes = 0;
    let quality = '';
    const seasons = {};
    
    if (series.episodes && Array.isArray(series.episodes)) {
        series.episodes.forEach(ep => {
            const seasonNum = ep.seasonNumber || 0;
            if (!seasons[seasonNum]) {
                seasons[seasonNum] = {
                    number: seasonNum,
                    episodes: [],
                    collected: 0,
                    total: 0,
                    size: 0
                };
            }
            seasons[seasonNum].total++;
            totalEpisodes++;
            
            if (ep.hasFile) {
                seasons[seasonNum].collected++;
                collectedEpisodes++;
                
                if (ep.file && ep.file.size) {
                    const epSize = parseInt(ep.file.size) || 0;
                    seasons[seasonNum].size += epSize;
                    totalSize += epSize;
                }
                
                if (!quality && ep.file && ep.file.quality) {
                    quality = String(ep.file.quality || '');
                }
            }
            
            seasons[seasonNum].episodes.push(ep);
        });
    }
    
    // Format runtime
    const runtime = series.runtime ? `${series.runtime} Minutes` : '';
    
    // Format air dates
    const yearStart = series.year || '';
    const yearEnd = series.yearEnd || '';
    const airDates = yearStart && yearEnd && yearStart !== yearEnd ? `${yearStart}-${yearEnd}` : (yearStart || '');
    
    // Get rating percentage
    const ratingPercent = series.ratings && series.ratings.tmdb ? Math.round((series.ratings.tmdb || 0) * 10) : null;
    
    // Determine if series has ended
    const status = series.status || '';
    const hasEnded = status.toLowerCase().includes('ended');
    
    let html = `
        <!-- Back Button -->
        <div style="margin-bottom: 20px;">
            <button class="action-btn" onclick="goBackToList('tv')" style="padding: 8px 16px; font-size: 0.9em; display: flex; align-items: center; gap: 8px;">
                ‚Üê Back to Sonarr
            </button>
        </div>
        
        <!-- Series Overview Section -->
        <div style="display: flex; gap: 20px; margin-bottom: 30px; flex-wrap: wrap; background: #1a1a1a; padding: 20px; border-radius: 8px;">
            <!-- Poster -->
            <div style="flex-shrink: 0;">
                ${series.posterUrl ? 
                    `<img src="${escapeHtml(String(series.posterUrl || ''))}" alt="${escapeHtml(String(series.title || ''))}" style="width: 200px; border-radius: 8px;">` :
                    `<div style="width: 200px; height: 300px; background: #0a0a0a; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 4em;">üì∫</div>`
                }
            </div>
            
            <!-- Series Info -->
            <div style="flex: 1; min-width: 300px;">
                <h1 style="margin: 0 0 15px 0; color: #fff; font-size: 2.2em; font-weight: 600;">${escapeHtml(String(series.title || ''))}</h1>
                
                <!-- Metadata Row -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; color: #aaa; font-size: 0.95em;">
                    ${runtime ? `<span>${escapeHtml(String(runtime || ''))}</span>` : ''}
                    ${ratingPercent !== null ? `<span style="color: var(--accent-color); font-weight: 600;">${ratingPercent}%</span>` : ''}
                    ${genres ? `<span>${escapeHtml(String(genres || ''))}</span>` : ''}
                    ${airDates ? `<span>${escapeHtml(String(airDates || ''))}</span>` : ''}
                </div>
                
                <!-- File Path -->
                ${series.path ? `
                    <div style="margin-bottom: 10px; color: #888; font-size: 0.9em; word-break: break-all;">
                        <strong style="color: #aaa;">Path:</strong> ${escapeHtml(String(series.path || ''))}
                    </div>
                ` : ''}
                
                <!-- Size and Quality -->
                <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; align-items: center; color: #aaa; font-size: 0.95em;">
                    ${totalSize > 0 ? `<span><strong style="color: #fff;">Total Size:</strong> ${formatSize(totalSize)}</span>` : ''}
                    ${quality ? `<span><strong style="color: #fff;">Quality:</strong> ${escapeHtml(String(quality || ''))}</span>` : ''}
                </div>
                
                <!-- Status Checkboxes -->
                <div style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; color: #aaa; cursor: pointer;">
                        <input type="checkbox" ${series.monitored ? 'checked' : ''} onchange="toggleMonitored('sonarr', ${series.id}, this.checked)" style="cursor: pointer;">
                        <span>Monitored</span>
                    </label>
                    ${hasEnded ? `
                        <label style="display: flex; align-items: center; gap: 8px; color: #aaa;">
                            <input type="checkbox" checked disabled style="cursor: not-allowed;">
                            <span>Ended</span>
                        </label>
                    ` : ''}
                    <label style="display: flex; align-items: center; gap: 8px; color: #aaa;">
                        <input type="checkbox" checked disabled style="cursor: not-allowed;">
                        <span>English</span>
                    </label>
                </div>
                
                <!-- Series-Level Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="action-btn" onclick="sonarrRefreshScan(${series.id})" style="padding: 8px 16px; font-size: 0.9em;">
                        üîÑ Refresh & Scan
                    </button>
                    <button class="action-btn" onclick="sonarrSearchScan(${series.id})" style="padding: 8px 16px; font-size: 0.9em;">
                        üîç Search Monitored
                    </button>
                    ${series.sonarrUrl ? `<button class="action-btn" onclick="window.open('${escapeHtml(String(series.sonarrUrl || ''))}', '_blank')" style="padding: 8px 16px; font-size: 0.9em;">üîó Open in Sonarr</button>` : ''}
                </div>
                
                <!-- Live search results (Search Monitored) - above main content -->
                <div id="tv-detail-search-results" class="media-detail-search-results" style="display: none; margin-bottom: 20px;"></div>
                
                <!-- Tags (if available) -->
                ${series.tags && series.tags.length > 0 ? `
                    <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;">
                        ${series.tags.map(tag => {
                            const tagName = String(tag.name || tag || '');
                            return `<span style="padding: 4px 10px; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 4px; font-size: 0.85em; color: #3498db; cursor: pointer;">${escapeHtml(tagName)}</span>`;
                        }).join('')}
                    </div>
                ` : ''}
                
                <!-- Overview -->
                ${series.overview ? `
                    <div style="margin-top: 20px;">
                        <p style="color: #aaa; line-height: 1.6; font-size: 0.95em;">${escapeHtml(String(series.overview || ''))}</p>
                    </div>
                ` : ''}
                
                <!-- Metadata Source -->
                <div style="margin-top: 20px; color: #666; font-size: 0.85em; text-align: right;">
                    Metadata is provided by TheTVDB
                </div>
            </div>
        </div>
    `;
    
    // Formats Section - show custom formats and score from episodes
    let allCustomFormats = new Set();
    let totalCustomFormatScore = 0; // sum all scores, not max
    let hasAnyFile = false;
    
    if (series.episodes && Array.isArray(series.episodes)) {
        series.episodes.forEach(ep => {
            if (ep.file) {
                hasAnyFile = true;
                // debug logging
                console.log('Episode file custom formats:', ep.file.customFormats);
                console.log('Episode file custom format score:', ep.file.customFormatScore);
                
                // extract custom formats - handle both string and object formats
                if (ep.file.customFormats && Array.isArray(ep.file.customFormats)) {
                    ep.file.customFormats.forEach(f => {
                        let formatName = '';
                        if (typeof f === 'string') {
                            formatName = f.trim();
                        } else if (f && typeof f === 'object') {
                            // try different possible field names
                            const name = f.name || f.label || f.title || '';
                            formatName = name ? String(name).trim() : '';
                        }
                        if (formatName && typeof formatName === 'string') {
                            // ensure it's a string before adding to Set
                            allCustomFormats.add(formatName.trim());
                        }
                    });
                }
                // use highest score from any episode file (each file has its own total)
                if (ep.file.customFormatScore !== undefined && ep.file.customFormatScore !== null) {
                    const score = parseInt(ep.file.customFormatScore) || 0;
                    if (score > totalCustomFormatScore) {
                        totalCustomFormatScore = score;
                    }
                }
            }
        });
    }
    
    console.log('All custom formats found:', Array.from(allCustomFormats));
    console.log('Total custom format score:', totalCustomFormatScore);
    
    // always show formats section if there are files
    if (hasAnyFile) {
        html += `
            <div style="margin-top: 30px; background: #1a1a1a; padding: 20px; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="color: var(--accent-color); margin: 0;">Formats</h2>
                </div>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
        `;
        
        // show format tags
        if (allCustomFormats.size > 0) {
            Array.from(allCustomFormats).forEach(formatName => {
                // ensure formatName is a string - extra defensive checks
                let formatStr = '';
                try {
                    if (formatName === null || formatName === undefined) {
                        return; // skip null/undefined
                    }
                    if (typeof formatName === 'string') {
                        formatStr = formatName.trim();
                    } else if (typeof formatName === 'object' && formatName !== null) {
                        // if it's an object, try to extract a string value
                        let name = formatName.name || formatName.label || formatName.title || '';
                        // if still no name, try calling toString (but safely)
                        if (!name && typeof formatName.toString === 'function') {
                            try {
                                name = formatName.toString();
                            } catch (e) {
                                // ignore toString errors
                            }
                        }
                        formatStr = name ? String(name).trim() : '';
                    } else {
                        formatStr = String(formatName || '').trim();
                    }
                    // final check - must be a non-empty string
                    if (formatStr && typeof formatStr === 'string') {
                        html += `<span style="display: inline-block; padding: 6px 12px; background: rgba(52, 152, 219, 0.2); border: 1px solid #3498db; border-radius: 6px; color: #3498db; font-size: 0.9em; font-weight: 500;">${escapeHtml(formatStr)}</span>`;
                    }
                } catch (e) {
                    console.warn('Error processing format name:', formatName, e);
                    // skip this format if there's any error
                }
            });
        }
        
        // show score (always show if present, even if 0)
        if (totalCustomFormatScore !== undefined && totalCustomFormatScore !== null) {
            const score = parseInt(totalCustomFormatScore) || 0;
            if (score > 0) {
                html += `<span style="color: var(--accent-color); font-weight: 600; font-size: 1.1em; margin-left: ${allCustomFormats.size > 0 ? '10px' : '0'};">+${score}</span>`;
            } else {
                html += `<span style="color: #888; font-size: 0.9em; margin-left: ${allCustomFormats.size > 0 ? '10px' : '0'};">0</span>`;
            }
        }
        
        // if we have neither formats nor score, show message
        if (allCustomFormats.size === 0 && (totalCustomFormatScore === undefined || totalCustomFormatScore === null || totalCustomFormatScore === 0)) {
            html += `<span style="color: #888; font-size: 0.9em;">No custom formats matched</span>`;
        }
        
        html += `
                </div>
            </div>
        `;
    }
    
    // Season/Episode List Section
    if (Object.keys(seasons).length > 0) {
        // Sort seasons (Specials/0 first, then 1, 2, 3...)
        const seasonNumbers = Object.keys(seasons).map(s => parseInt(s)).sort((a, b) => {
            if (a === 0) return 1; // Move 0 to end
            if (b === 0) return -1;
            return b - a; // Descending order (newest first)
        });
        
        html += `
            <div style="margin-top: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="color: var(--accent-color); margin: 0;">Seasons & Episodes</h2>
                    <button class="action-btn" onclick="expandAllSeasons()" style="padding: 6px 12px; font-size: 0.85em;">
                        Expand All
                    </button>
                </div>
        `;
        
        seasonNumbers.forEach(seasonNum => {
            const season = seasons[seasonNum];
            const seasonId = `season-${seriesId}-${seasonNum}`;
            const isCollected = season.collected === season.total && season.total > 0;
            const episodeCountColor = isCollected ? '#00CC66' : (season.collected > 0 ? '#f39c12' : '#e74c3c');
            const seasonLabel = seasonNum === 0 ? 'Specials' : `Season ${seasonNum}`;
            
            html += `
                <div class="season-panel" data-season-id="${seasonId}" style="background: #1a1a1a; border-radius: 8px; margin-bottom: 10px; overflow: hidden;">
                    <!-- Season Header -->
                    <div class="season-header" onclick="toggleSeason('${seasonId}')" style="display: flex; align-items: center; padding: 12px 15px; cursor: pointer; user-select: none; background: #222; border-bottom: 1px solid #333;">
                        <span style="margin-right: 10px; font-size: 1.1em;">üìñ</span>
                        <div style="flex: 1;">
                            <span style="color: #fff; font-weight: 600; font-size: 1em;">${escapeHtml(seasonLabel)}</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px; margin-right: 15px;">
                            <span style="color: ${episodeCountColor}; font-weight: 600;">
                                ${season.collected}/${season.total}
                            </span>
                            ${season.size > 0 ? `<span style="color: #aaa; font-size: 0.9em;">${formatSize(season.size)}</span>` : ''}
                        </div>
                        <!-- Season Actions (search, interactive search, refresh) -->
                        <div style="display: flex; gap: 5px; margin-right: 10px;">
                            <button onclick="event.stopPropagation(); searchSeason(${series.id}, ${seasonNum})" title="Search Season" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em;">üîç</button>
                            <button onclick="event.stopPropagation(); sonarrInteractiveSearch(${series.id}, '${escapeJsString(series.title || '')}', ${seasonNum})" title="Interactive Search" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em;">üéØ</button>
                            <button onclick="event.stopPropagation(); refreshSeason(${series.id}, ${seasonNum})" title="Refresh Season" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em;">üîÑ</button>
                        </div>
                        <span class="season-toggle" style="color: #aaa; font-size: 1.2em; transition: transform 0.2s;">‚ñº</span>
                    </div>
                    
                    <!-- Season Episodes (Collapsed by default) -->
                    <div class="season-episodes" id="${seasonId}" style="display: none; padding: 0;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #0a0a0a;">
                                    <th style="padding: 10px; text-align: left; color: #aaa; font-weight: 600; font-size: 0.9em; width: 60px;">#</th>
                                    <th style="padding: 10px; text-align: left; color: #aaa; font-weight: 600; font-size: 0.9em;">Title</th>
                                    <th style="padding: 10px; text-align: left; color: #aaa; font-weight: 600; font-size: 0.9em; width: 120px;">Air Date</th>
                                    <th style="padding: 10px; text-align: left; color: #aaa; font-weight: 600; font-size: 0.9em; width: 150px;">Status</th>
                                    <th style="padding: 10px; text-align: right; color: #aaa; font-weight: 600; font-size: 0.9em; width: 120px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            // Sort episodes by episode number
            season.episodes.sort((a, b) => (a.episodeNumber || 0) - (b.episodeNumber || 0));
            
            season.episodes.forEach(ep => {
                const epNum = ep.episodeNumber || 0;
                const epTitle = String(ep.title || 'Untitled');
                const airDate = ep.airDate ? new Date(ep.airDate).toLocaleDateString() : 'N/A';
                const hasFile = ep.hasFile || false;
                
                // Show downloaded when Sonarr says hasFile (even if file details weren't expanded)
                let statusText = 'Missing';
                let statusColor = '#e74c3c';
                
                if (hasFile) {
                    statusText = (ep.file && ep.file.quality) ? String(ep.file.quality) : 'Downloaded';
                    statusColor = '#00CC66';
                } else if (ep.queueStatus) {
                    if (ep.queueStatus === 'paused') {
                        statusText = 'Paused';
                        statusColor = '#f39c12'; // orange for paused
                    } else if (ep.queueStatus === 'downloading') {
                        statusText = 'Downloading';
                        statusColor = '#3498db'; // blue for downloading
                    } else if (ep.queueStatus === 'queued') {
                        statusText = 'Queued';
                        statusColor = '#9b59b6'; // purple for queued
                    }
                }
                
                html += `
                    <tr style="border-bottom: 1px solid #222; cursor: pointer;" onclick="showEpisodeDetailModal(${ep.id}, ${seasonNum})" title="View episode details">
                        <td style="padding: 10px; color: #aaa; font-size: 0.9em;">${epNum}</td>
                        <td style="padding: 10px; color: #fff;">
                            ${escapeHtml(epTitle)}
                            ${ep.episodeNumber === season.episodes.length && seasonNum !== 0 ? '<span style="color: #f39c12; margin-left: 8px; font-size: 0.85em;">Series Finale</span>' : ''}
                        </td>
                        <td style="padding: 10px; color: #aaa; font-size: 0.9em;">${escapeHtml(airDate)}</td>
                        <td style="padding: 10px; color: ${statusColor}; font-size: 0.9em; font-weight: 600;" title="${ep.queueTitle ? escapeHtml(ep.queueTitle) : ''}">
                            ${escapeHtml(statusText)}
                            ${ep.queueStatus === 'paused' && ep.queueSizeLeft && ep.queueSize ? 
                                ` (${Math.round(((ep.queueSize - ep.queueSizeLeft) / ep.queueSize) * 100)}%)` : ''}
                            ${ep.queueStatus === 'downloading' && ep.queueSizeLeft && ep.queueSize ? 
                                ` (${Math.round(((ep.queueSize - ep.queueSizeLeft) / ep.queueSize) * 100)}%)` : ''}
                        </td>
                        <td style="padding: 10px; text-align: right;" onclick="event.stopPropagation();">
                            <div style="display: flex; gap: 5px; justify-content: flex-end;">
                                <button onclick="event.stopPropagation(); searchEpisode(${series.id}, ${ep.id || epNum}, ${seasonNum})" title="Search Episode" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em; transition: color 0.2s;" onmouseover="this.style.color='#3498db'" onmouseout="this.style.color='#aaa'">üîç</button>
                                <button onclick="event.stopPropagation(); manualImportEpisode(${series.id}, ${ep.id || epNum}, ${seasonNum})" title="Manual Import" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em; transition: color 0.2s;" onmouseover="this.style.color='#3498db'" onmouseout="this.style.color='#aaa'">üìÅ</button>
                                <button onclick="event.stopPropagation(); refreshEpisode(${series.id}, ${ep.id || epNum}, ${seasonNum})" title="Refresh Episode" style="background: transparent; border: none; color: #aaa; cursor: pointer; padding: 4px; font-size: 1em; transition: color 0.2s;" onmouseover="this.style.color='#3498db'" onmouseout="this.style.color='#aaa'">üîÑ</button>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        });
        
        html += `</div>`;
    }
    
    // Cast Section
    if (series.cast && Array.isArray(series.cast) && series.cast.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Cast</h2>
                <div style="display: flex; gap: 15px; overflow-x: auto; padding-bottom: 10px;">
        `;
        series.cast.forEach(person => {
            const personName = String(person.name || '');
            const personChar = String(person.character || '');
            const profilePath = String(person.profile_path || '');
            html += `
                <div style="min-width: 120px; text-align: center;">
                    ${profilePath ? 
                        `<img src="https://image.tmdb.org/t/p/w185${escapeHtml(profilePath)}" alt="${escapeHtml(personName)}" style="width: 120px; height: 180px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;">` :
                        `<div style="width: 120px; height: 180px; background: #1a1a1a; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; font-size: 2em;">üë§</div>`
                    }
                    <div style="color: #fff; font-weight: 600; margin-bottom: 4px;">${escapeHtml(personName)}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${escapeHtml(personChar)}</div>
                </div>
            `;
        });
        html += `
                </div>
            </div>
        `;
    }
    
    // Crew Section
    if (series.crew && Array.isArray(series.crew) && series.crew.length > 0) {
        html += `
            <div style="margin-top: 30px;">
                <h2 style="color: var(--accent-color); margin-bottom: 15px;">Crew</h2>
                <div style="display: flex; gap: 15px; overflow-x: auto; padding-bottom: 10px;">
        `;
        series.crew.forEach(person => {
            const personName = String(person.name || '');
            const personJob = String(person.job || '');
            const profilePath = String(person.profile_path || '');
            html += `
                <div style="min-width: 120px; text-align: center;">
                    ${profilePath ? 
                        `<img src="https://image.tmdb.org/t/p/w185${escapeHtml(profilePath)}" alt="${escapeHtml(personName)}" style="width: 120px; height: 180px; object-fit: cover; border-radius: 8px; margin-bottom: 8px;">` :
                        `<div style="width: 120px; height: 180px; background: #1a1a1a; border-radius: 8px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; font-size: 2em;">üë§</div>`
                    }
                    <div style="color: #fff; font-weight: 600; margin-bottom: 4px;">${escapeHtml(personName)}</div>
                    <div style="color: #aaa; font-size: 0.9em;">${escapeHtml(personJob)}</div>
                </div>
            `;
        });
        html += `
                </div>
            </div>
        `;
    }
    
    container.innerHTML = html;
}

// Season/Episode interaction functions
function toggleSeason(seasonId) {
    const episodesDiv = document.getElementById(seasonId);
    const toggle = document.querySelector(`[data-season-id="${seasonId}"] .season-toggle`);
    if (episodesDiv && toggle) {
        const isVisible = episodesDiv.style.display !== 'none';
        episodesDiv.style.display = isVisible ? 'none' : 'block';
        toggle.textContent = isVisible ? '‚ñº' : '‚ñ≤';
        toggle.style.transform = isVisible ? 'rotate(0deg)' : 'rotate(180deg)';
    }
}

function expandAllSeasons() {
    const allSeasons = document.querySelectorAll('.season-episodes');
    const allToggles = document.querySelectorAll('.season-toggle');
    allSeasons.forEach(div => {
        div.style.display = 'block';
    });
    allToggles.forEach(toggle => {
        toggle.textContent = '‚ñ≤';
        toggle.style.transform = 'rotate(180deg)';
    });
}

function showEpisodeDetailModal(epId, seasonNum) {
    const series = window._currentSonarrSeries;
    if (!series || !series.episodes) {
        return;
    }
    const ep = series.episodes.find(e => e.id === epId);
    if (!ep) {
        return;
    }
    const seriesTitle = String(series.title || '');
    const epTitle = String(ep.title || 'Untitled');
    const sxe = `${seasonNum}x${String(ep.episodeNumber || 0).padStart(2, '0')}`;
    document.getElementById('episodeDetailModalTitle').textContent = `${seriesTitle} - ${sxe} - ${epTitle}`;

    let airsStr = 'N/A';
    if (ep.airDate) {
        try {
            const d = new Date(ep.airDate);
            airsStr = `Airs ${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
        } catch (e) {
            airsStr = String(ep.airDate);
        }
    }

    let body = `
        <div style="color: #aaa; font-size: 0.95em;">
            <div style="margin-bottom: 12px;"><strong style="color: #888;">Airs</strong> ${escapeHtml(airsStr)}</div>
            <div style="margin-bottom: 12px;"><strong style="color: #888;">Quality</strong> ${ep.file && ep.file.quality ? escapeHtml(String(ep.file.quality)) : 'N/A'}</div>
            ${ep.overview ? `<div style="margin-bottom: 15px;"><strong style="color: #888;">Synopsis</strong><p style="margin: 6px 0 0 0; line-height: 1.5;">${escapeHtml(String(ep.overview))}</p></div>` : ''}
    `;

    if (ep.file) {
        const path = ep.file.path || '';
        const size = ep.file.size ? formatSize(ep.file.size) : '-';
        const quality = ep.file.quality || '-';
        const langs = (ep.file.languages && ep.file.languages.length) ? ep.file.languages.map(l => escapeHtml(String(l))).join(', ') : '-';
        const formats = (ep.file.customFormats && ep.file.customFormats.length) ? ep.file.customFormats.map(f => `<span style="display: inline-block; padding: 2px 8px; margin: 2px 4px 2px 0; background: rgba(52, 152, 219, 0.2); border-radius: 4px; font-size: 0.85em;">${escapeHtml(String(f))}</span>`).join('') : '-';
        const score = (ep.file.customFormatScore !== undefined && ep.file.customFormatScore !== null) ? `+${ep.file.customFormatScore}` : '';
        body += `
            <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 15px;">
                <strong style="color: #aaa;">File</strong>
                <table style="width: 100%; margin-top: 8px; border-collapse: collapse; font-size: 0.9em;">
                    <thead><tr style="color: #888; text-align: left;"><th style="padding: 6px 8px;">Path</th><th style="padding: 6px 8px;">Size</th><th style="padding: 6px 8px;">Languages</th><th style="padding: 6px 8px;">Quality</th><th style="padding: 6px 8px;">Formats</th></tr></thead>
                    <tbody>
                        <tr style="border-top: 1px solid #222;">
                            <td style="padding: 8px; color: #aaa; word-break: break-all;">${escapeHtml(path)}</td>
                            <td style="padding: 8px; color: #aaa;">${size}</td>
                            <td style="padding: 8px; color: #aaa;">${langs}</td>
                            <td style="padding: 8px; color: #aaa;">${escapeHtml(quality)}</td>
                            <td style="padding: 8px; color: #aaa;">${formats === '-' ? '-' : formats} ${score ? `<span style="color: var(--accent-color); font-weight: 600;">${score}</span>` : ''}</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        `;
    } else {
        body += `<div style="margin-top: 15px; color: #888;">No file for this episode.</div>`;
    }

    body += `</div>`;
    document.getElementById('episodeDetailModalBody').innerHTML = body;
    document.getElementById('episodeDetailModal').style.display = 'block';
}

function closeEpisodeDetailModal() {
    const modal = document.getElementById('episodeDetailModal');
    if (modal) modal.style.display = 'none';
}

function searchSeason(seriesId, seasonNumber) {
    const inlineEl = document.getElementById('tv-detail-search-results');
    if (inlineEl) {
        inlineEl.style.display = 'block';
        inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 8px; color: var(--accent-color); font-weight: 600;">üîç Search Season ' + seasonNumber + '</div><div class="search-monitored-status" style="color: #aaa; font-size: 0.95em;">Starting search‚Ä¶</div><div class="search-monitored-progress" style="color: #888; font-size: 0.9em; margin-top: 6px;"></div>';
    }
    fetch(API_SONARR_SEARCH_SEASON_BASE.replace(/\/0\/0$/, '/' + seriesId + '/' + seasonNumber), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                clearCachedDetail('series', seriesId);
                if (inlineEl) {
                    inlineEl.querySelector('.search-monitored-status').textContent = 'Sonarr is searching for missing episodes in this season and will grab the best match.';
                    pollSonarrSearchStatus(seriesId, inlineEl);
                } else {
                    alert(`Search started for Season ${seasonNumber}!`);
                }
            } else {
                if (inlineEl) {
                    inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Season ' + seasonNumber + '</div><div style="padding: 16px; color: #e74c3c;">' + escapeHtml(String(data.message || 'Failed to start search')) + '</div>';
                } else {
                    alert('Error: ' + (data.message || 'Failed to start search'));
                }
            }
        })
        .catch(err => {
            if (inlineEl) {
                inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Season ' + seasonNumber + '</div><div style="padding: 16px; color: #e74c3c;">Error: ' + escapeHtml(String(err.message)) + '</div>';
            } else {
                alert('Error: ' + err.message);
            }
        });
}

function refreshSeason(seriesId, seasonNumber) {
    // Trigger refresh for season
    fetch(API_SONARR_REFRESH_SEASON_BASE.replace(/\/0\/0$/, '/' + seriesId + '/' + seasonNumber), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                alert(`Refresh started for Season ${seasonNumber}!`);
                clearCachedDetail('series', seriesId);
                setTimeout(() => showSeriesDetail(seriesId, true), 2000);
            } else {
                alert('Error: ' + (data.message || 'Failed to start refresh'));
            }
        })
        .catch(err => alert('Error: ' + err.message));
}

function searchEpisode(seriesId, episodeId, seasonNumber) {
    const inlineEl = document.getElementById('tv-detail-search-results');
    if (inlineEl) {
        inlineEl.style.display = 'block';
        inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 8px; color: var(--accent-color); font-weight: 600;">üîç Search Episode</div><div class="search-monitored-status" style="color: #aaa; font-size: 0.95em;">Starting search‚Ä¶</div><div class="search-monitored-progress" style="color: #888; font-size: 0.9em; margin-top: 6px;"></div>';
    }
    fetch(API_SONARR_SEARCH_EPISODE_BASE.replace(/\/0$/, '/' + episodeId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                clearCachedDetail('series', seriesId);
                if (inlineEl) {
                    inlineEl.querySelector('.search-monitored-status').textContent = 'Sonarr is searching for this episode and will grab the best match.';
                    pollSonarrSearchStatus(seriesId, inlineEl);
                } else {
                    alert('Search started for episode!');
                }
            } else {
                if (inlineEl) {
                    inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Episode</div><div style="padding: 16px; color: #e74c3c;">' + escapeHtml(String(data.message || 'Failed to start search')) + '</div>';
                } else {
                    alert('Error: ' + (data.message || 'Failed to start search'));
                }
            }
        })
        .catch(err => {
            if (inlineEl) {
                inlineEl.innerHTML = '<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Episode</div><div style="padding: 16px; color: #e74c3c;">Error: ' + escapeHtml(String(err.message)) + '</div>';
            } else {
                alert('Error: ' + err.message);
            }
        });
}

function manualImportEpisode(seriesId, episodeId, seasonNumber) {
    // Open manual import dialog (placeholder - would need API endpoint)
    alert('Manual import feature coming soon!');
    // In a full implementation, this would open a modal to select files
}

function refreshEpisode(seriesId, episodeId, seasonNumber) {
    // Trigger refresh for specific episode
    fetch(API_SONARR_REFRESH_EPISODE_BASE.replace(/\/0$/, '/' + episodeId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                alert('Refresh started for episode!');
                clearCachedDetail('series', seriesId);
                setTimeout(() => showSeriesDetail(seriesId, true), 1500);
            } else {
                alert('Error: ' + (data.message || 'Failed to start refresh'));
            }
        })
        .catch(err => alert('Error: ' + err.message));
}

function radarrRefreshScan(movieId) {
    fetch(API_RADARR_REFRESH_BASE.replace(/\/0$/, '/' + movieId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                // Clear cache since data may have changed
                clearCachedDetail('movies', movieId);
                alert('Refresh and scan started!');
                // Refresh detail view if open
                const detailContainer = document.getElementById('movies-detail-container');
                if (detailContainer && detailContainer.style.display !== 'none') {
                    showMovieDetail(movieId, true);
                }
            } else {
                alert('Error: ' + (data.message || 'Failed to start refresh'));
            }
        })
        .catch(err => alert('Error: ' + err.message));
}

function radarrSearchScan(movieId) {
    const useInline = (window._currentDetailMovieId === movieId);
    const inlineEl = useInline ? document.getElementById('movies-detail-search-results') : null;
    let title = 'Movie';
    const h1 = document.querySelector('#movies-detail-container h1');
    if (h1) title = (h1.textContent || '').trim().replace(/\s*\(\d{4}\)\s*$/, '').trim() || title;

    fetch(API_RADARR_SEARCH_SCAN_BASE.replace(/\/0$/, '/' + movieId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                clearCachedDetail('movies', movieId);
                if (useInline && inlineEl) {
                    inlineEl.style.display = 'block';
                    inlineEl.innerHTML = `
                        <div class="media-detail-search-results-header" style="margin-bottom: 8px; color: var(--accent-color); font-weight: 600;">üîç Search Movie</div>
                        <div class="search-movie-status" style="color: #aaa; font-size: 0.95em; line-height: 1.5;">
                            Radarr is searching indexers and will automatically grab the best match for your quality profile.
                        </div>
                        <div class="search-movie-progress" style="color: #888; font-size: 0.9em; margin-top: 6px;"></div>
                    `;
                    pollRadarrSearchStatus(movieId, inlineEl);
                } else {
                    alert('Search Movie started! Radarr will grab the best match for your quality profile.');
                }
                // don't refresh detail when showing inline (would wipe the results area)
                if (!useInline) {
                    const detailContainer = document.getElementById('movies-detail-container');
                    if (detailContainer && detailContainer.style.display !== 'none') {
                        showMovieDetail(movieId, true);
                    }
                }
            } else {
                if (useInline && inlineEl) {
                    inlineEl.style.display = 'block';
                    inlineEl.innerHTML = `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Movie</div><div style="text-align: center; padding: 24px; color: #e74c3c;">${escapeHtml(String(data.message || 'Failed to start search'))}</div>`;
                } else {
                    alert('Error: ' + (data.message || 'Failed to start search'));
                }
            }
        })
        .catch(err => {
            if (useInline && inlineEl) {
                inlineEl.style.display = 'block';
                inlineEl.innerHTML = `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Movie</div><div style="text-align: center; padding: 24px; color: #e74c3c;">Error: ${escapeHtml(String(err.message))}</div>`;
            } else {
                alert('Error: ' + err.message);
            }
        });
}

// Search Movie: poll lightweight queue-check so we see updates quickly (~4s in Radarr)
const RADARR_SEARCH_POLL_MS = 1500;
const RADARR_SEARCH_POLL_MAX = 10; // ~15s

function pollRadarrSearchStatus(movieId, inlineEl) {
    let pollCount = 0;

    function setProgress(msg) {
        const progressEl = inlineEl.querySelector('.search-movie-progress');
        if (progressEl) progressEl.textContent = msg;
    }

    setProgress('Checking for queue updates‚Ä¶');

    function doPoll() {
        if (pollCount >= RADARR_SEARCH_POLL_MAX) {
            const statusEl = inlineEl.querySelector('.search-movie-status');
            const progressEl = inlineEl.querySelector('.search-movie-progress');
            if (statusEl && statusEl.textContent.indexOf('Queued') === -1 && statusEl.textContent.indexOf('Downloading') === -1 && statusEl.textContent.indexOf('Paused') === -1) {
                statusEl.innerHTML = 'Search finished. If nothing was grabbed, no release met your quality profile.';
                if (progressEl) progressEl.innerHTML = 'Refresh the page or check the queue in Radarr.';
            }
            return;
        }
        pollCount += 1;
        const elapsed = (pollCount * RADARR_SEARCH_POLL_MS) / 1000;
        setProgress(`Checking for queue updates‚Ä¶ (${elapsed}s)`);

        fetch(API_RADARR_QUEUE_CHECK_BASE.replace(/\/0$/, '/' + movieId))
            .then(r => r.json())
            .then(data => {
                if (data.status === 'error') {
                    if (pollCount < RADARR_SEARCH_POLL_MAX) setTimeout(doPoll, RADARR_SEARCH_POLL_MS);
                    return;
                }
                if (data.inQueue && (data.queueStatus || data.queueTitle)) {
                    const status = data.queueStatus || 'queued';
                    const title = data.queueTitle || 'Release';
                    const statusEl = inlineEl.querySelector('.search-movie-status');
                    const progressEl = inlineEl.querySelector('.search-movie-progress');
                    if (statusEl) {
                        if (status === 'downloading') statusEl.innerHTML = `Downloading: <strong>${escapeHtml(title)}</strong>`;
                        else if (status === 'paused') statusEl.innerHTML = `Paused: <strong>${escapeHtml(title)}</strong>`;
                        else statusEl.innerHTML = `Queued: <strong>${escapeHtml(title)}</strong>`;
                    }
                    if (progressEl) progressEl.textContent = '';
                    return;
                }
                // already have the best available; nothing to grab
                if (!data.inQueue && data.hasFile) {
                    const statusEl = inlineEl.querySelector('.search-movie-status');
                    const progressEl = inlineEl.querySelector('.search-movie-progress');
                    if (statusEl) statusEl.innerHTML = 'Already have the best available - nothing to grab.';
                    if (progressEl) progressEl.textContent = '';
                    return;
                }
                if (pollCount < RADARR_SEARCH_POLL_MAX) setTimeout(doPoll, RADARR_SEARCH_POLL_MS);
            })
            .catch(() => {
                setProgress(`Check failed, retrying‚Ä¶ (${pollCount}/${RADARR_SEARCH_POLL_MAX})`);
                if (pollCount < RADARR_SEARCH_POLL_MAX) setTimeout(doPoll, RADARR_SEARCH_POLL_MS);
            });
    }

    // first poll after 1.5s so we catch ~4s grabs quickly
    setTimeout(doPoll, RADARR_SEARCH_POLL_MS);
}

function sonarrRefreshScan(seriesId) {
    fetch(API_SONARR_REFRESH_BASE.replace(/\/0$/, '/' + seriesId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                // Clear cache since data may have changed
                clearCachedDetail('series', seriesId);
                alert('Refresh and scan started!');
                // Refresh detail view if open
                const detailContainer = document.getElementById('tv-detail-container');
                if (detailContainer && detailContainer.style.display !== 'none') {
                    showSeriesDetail(seriesId, true);
                }
            } else {
                alert('Error: ' + (data.message || 'Failed to start refresh'));
            }
        })
        .catch(err => alert('Error: ' + err.message));
}

function sonarrSearchScan(seriesId) {
    const useInline = (window._currentDetailSeriesId === seriesId);
    const inlineEl = useInline ? document.getElementById('tv-detail-search-results') : null;
    let title = 'Series';
    const h1 = document.querySelector('#tv-detail-container h1');
    if (h1) title = (h1.textContent || '').trim().replace(/\s*\(\d{4}\)\s*$/, '').trim() || title;

    fetch(API_SONARR_SEARCH_SCAN_BASE.replace(/\/0$/, '/' + seriesId), {method: 'POST'})
        .then(r => r.json())
        .then(data => {
            if (data.status === 'success') {
                clearCachedDetail('series', seriesId);
                if (useInline && inlineEl) {
                    inlineEl.style.display = 'block';
                    inlineEl.innerHTML = `
                        <div class="media-detail-search-results-header" style="margin-bottom: 8px; color: var(--accent-color); font-weight: 600;">üîç Search Monitored</div>
                        <div class="search-monitored-status" style="color: #aaa; font-size: 0.95em; line-height: 1.5;">
                            Sonarr is searching all monitored episodes/seasons and will automatically grab the best match for each missing episode.
                        </div>
                        <div class="search-monitored-progress" style="color: #888; font-size: 0.9em; margin-top: 6px;"></div>
                    `;
                    pollSonarrSearchStatus(seriesId, inlineEl);
                } else {
                    alert('Search Monitored started! Sonarr will grab the best match for each missing episode.');
                }
                if (!useInline) {
                    const detailContainer = document.getElementById('tv-detail-container');
                    if (detailContainer && detailContainer.style.display !== 'none') {
                        showSeriesDetail(seriesId, true);
                    }
                }
            } else {
                if (useInline && inlineEl) {
                    inlineEl.style.display = 'block';
                    inlineEl.innerHTML = `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Monitored</div><div style="text-align: center; padding: 24px; color: #e74c3c;">${escapeHtml(String(data.message || 'Failed to start search'))}</div>`;
                } else {
                    alert('Error: ' + (data.message || 'Failed to start search'));
                }
            }
        })
        .catch(err => {
            if (useInline && inlineEl) {
                inlineEl.style.display = 'block';
                inlineEl.innerHTML = `<div class="media-detail-search-results-header" style="margin-bottom: 12px; color: var(--accent-color);">üîç Search Monitored</div><div style="text-align: center; padding: 24px; color: #e74c3c;">Error: ${escapeHtml(String(err.message))}</div>`;
            } else {
                alert('Error: ' + err.message);
            }
        });
}

// Search Monitored: poll lightweight queue-check so we see updates quickly
const SONARR_SEARCH_POLL_MS = 1500;
const SONARR_SEARCH_POLL_MAX = 10; // ~15s

function pollSonarrSearchStatus(seriesId, inlineEl) {
    let pollCount = 0;

    function setProgress(msg) {
        const progressEl = inlineEl.querySelector('.search-monitored-progress');
        if (progressEl) progressEl.textContent = msg;
    }

    setProgress('Checking for queue updates‚Ä¶');

    function doPoll() {
        if (pollCount >= SONARR_SEARCH_POLL_MAX) {
            const statusEl = inlineEl.querySelector('.search-monitored-status');
            const progressEl = inlineEl.querySelector('.search-monitored-progress');
            const hasQueueResult = statusEl && statusEl.textContent.indexOf('in queue') !== -1;
            if (statusEl && !hasQueueResult) {
                statusEl.innerHTML = 'Search finished. If nothing was grabbed, no release met your quality profile for missing episodes.';
            }
            if (progressEl) {
                progressEl.textContent = hasQueueResult ? 'Done. Refresh the page to see updates.' : 'Refresh the page or check the queue in Sonarr.';
            }
            return;
        }
        pollCount += 1;
        const elapsed = (pollCount * SONARR_SEARCH_POLL_MS) / 1000;
        setProgress(`Checking for queue updates‚Ä¶ (${Math.round(elapsed)}s)`);

        fetch(API_SONARR_QUEUE_CHECK_BASE.replace(/\/0$/, '/' + seriesId))
            .then(r => r.json())
            .then(data => {
                if (data.status === 'error') {
                    if (pollCount >= SONARR_SEARCH_POLL_MAX) {
                        const statusEl = inlineEl.querySelector('.search-monitored-status');
                        const progressEl = inlineEl.querySelector('.search-monitored-progress');
                        if (statusEl) statusEl.innerHTML = 'Search finished. If nothing was grabbed, no release met your quality profile for missing episodes.';
                        if (progressEl) progressEl.textContent = 'Refresh the page or check the queue in Sonarr.';
                        return;
                    }
                    setTimeout(doPoll, SONARR_SEARCH_POLL_MS);
                    return;
                }
                const items = data.queueItems || [];
                if (data.inQueue && items.length > 0) {
                    const statusEl = inlineEl.querySelector('.search-monitored-status');
                    const progressEl = inlineEl.querySelector('.search-monitored-progress');
                    if (statusEl) {
                        const titles = items.slice(0, 3).map(it => it.queueTitle || 'Episode').join(', ');
                        const more = items.length > 3 ? ` +${items.length - 3} more` : '';
                        statusEl.innerHTML = `${items.length} episode(s) in queue: <strong>${escapeHtml(titles)}</strong>${escapeHtml(more)}`;
                    }
                    if (progressEl) progressEl.textContent = 'Done. Refresh the page to see updates.';
                    return;
                }
                // all monitored episodes already downloaded - nothing to grab
                if (!data.inQueue && data.allMonitoredDownloaded) {
                    const statusEl = inlineEl.querySelector('.search-monitored-status');
                    const progressEl = inlineEl.querySelector('.search-monitored-progress');
                    if (statusEl) statusEl.innerHTML = 'All episodes already downloaded - nothing to grab.';
                    if (progressEl) progressEl.textContent = '';
                    return;
                }
                if (pollCount >= SONARR_SEARCH_POLL_MAX) {
                    const statusEl = inlineEl.querySelector('.search-monitored-status');
                    const progressEl = inlineEl.querySelector('.search-monitored-progress');
                    const hasQueueResult = statusEl && statusEl.textContent.indexOf('in queue') !== -1;
                    if (statusEl && !hasQueueResult) statusEl.innerHTML = 'Search finished. If nothing was grabbed, no release met your quality profile for missing episodes.';
                    if (progressEl) progressEl.textContent = hasQueueResult ? 'Done. Refresh the page to see updates.' : 'Refresh the page or check the queue in Sonarr.';
                    return;
                }
                setTimeout(doPoll, SONARR_SEARCH_POLL_MS);
            })
            .catch(() => {
                setProgress(`Check failed, retrying‚Ä¶ (${pollCount}/${SONARR_SEARCH_POLL_MAX})`);
                if (pollCount >= SONARR_SEARCH_POLL_MAX) {
                    const progressEl = inlineEl.querySelector('.search-monitored-progress');
                    if (progressEl) progressEl.textContent = 'Refresh the page or check the queue in Sonarr.';
                    return;
                }
                setTimeout(doPoll, SONARR_SEARCH_POLL_MS);
            });
    }

    setTimeout(doPoll, SONARR_SEARCH_POLL_MS);
}

// Close detail modal with ESC key
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        // Check if detail view is open and close it
        const moviesDetail = document.getElementById('movies-detail-container');
        const tvDetail = document.getElementById('tv-detail-container');
        if (moviesDetail && moviesDetail.style.display !== 'none') {
            goBackToList('movies');
        } else if (tvDetail && tvDetail.style.display !== 'none') {
            goBackToList('tv');
        }
        const searchModal = document.getElementById('searchModal');
        if (searchModal && searchModal.style.display !== 'none') {
            closeSearchModal();
        }
    }
});

// Background cache validation: Periodically check if cached items still exist
// This prevents showing deleted items and reduces stale data
// Strategy:
// 1. TTL-based expiration (2 minutes) - automatic cleanup of old cache
// 2. List-based invalidation - when lists load, remove cache for items not in current list
// 3. Action-based invalidation - clear cache when actions are performed (monitor toggle, refresh, etc.)
// 4. Background validation - periodic cleanup of expired entries
// 5. Deletion detection - API returns deleted:true for 404s, which triggers cache clear
let cacheValidationInterval = null;

function startCacheValidation() {
    // Run validation every 2 minutes (longer than TTL to avoid excessive API calls)
    // This cleans up expired entries and ensures cache doesn't grow indefinitely
    if (cacheValidationInterval) {
        clearInterval(cacheValidationInterval);
    }
    
    // Validation interval should be 2-3x the TTL to avoid excessive cleanup
    const validationInterval = Math.max(detailCache.TTL * 2, 2 * 60 * 1000); // At least 2 minutes
    
    cacheValidationInterval = setInterval(() => {
        // Expire old cache entries (beyond TTL)
        const now = Date.now();
        let expiredCount = 0;
        ['movies', 'series'].forEach(type => {
            const cache = detailCache[type];
            for (const id in cache) {
                const age = now - cache[id].timestamp;
                if (age >= detailCache.TTL) {
                    delete cache[id];
                    expiredCount++;
                }
            }
        });
        
        // Also validate against current lists if they've been loaded
        if (detailCache.currentMovieIds.size > 0) {
            invalidateDeletedItems('movies');
        }
        if (detailCache.currentSeriesIds.size > 0) {
            invalidateDeletedItems('series');
        }
        
        if (expiredCount > 0) {
            console.log(`Cache cleanup: Expired ${expiredCount} cached detail(s)`);
        }
    }, validationInterval);
}

// Load data on page load
document.addEventListener('DOMContentLoaded', function() {
    // Load saved page size preferences from localStorage
    const savedPageSizeRequested = localStorage.getItem('pageSizeRequested');
    if (savedPageSizeRequested) {
        const select = document.getElementById('page-size-requested');
        if (select) select.value = savedPageSizeRequested;
    }
    
    const savedPageSizeMovies = localStorage.getItem('pageSizeMovies');
    if (savedPageSizeMovies) {
        const select = document.getElementById('page-size-movies');
        if (select) select.value = savedPageSizeMovies;
    }
    
    const savedPageSizeTV = localStorage.getItem('pageSizeTV');
    if (savedPageSizeTV) {
        const select = document.getElementById('page-size-tv');
        if (select) select.value = savedPageSizeTV;
    }
    
    // Start background cache validation
    startCacheValidation();
    
    loadMediaData();
});
</script>

{% endblock %}
